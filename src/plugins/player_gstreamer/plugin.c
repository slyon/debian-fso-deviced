/* plugin.c generated by valac 0.14.2, the Vala compiler
 * generated from plugin.vala, do not modify */

/*
 * Copyright (C) 2009-2011 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <fsodevice.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <gst/gst.h>
#include <fsobasics.h>
#include <gio/gio.h>
#include <freesmartphone.h>
#include <fsoframework.h>


#define PLAYER_TYPE_GSTREAMER (player_gstreamer_get_type ())
#define PLAYER_GSTREAMER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLAYER_TYPE_GSTREAMER, PlayerGstreamer))
#define PLAYER_GSTREAMER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLAYER_TYPE_GSTREAMER, PlayerGstreamerClass))
#define PLAYER_IS_GSTREAMER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLAYER_TYPE_GSTREAMER))
#define PLAYER_IS_GSTREAMER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLAYER_TYPE_GSTREAMER))
#define PLAYER_GSTREAMER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLAYER_TYPE_GSTREAMER, PlayerGstreamerClass))

typedef struct _PlayerGstreamer PlayerGstreamer;
typedef struct _PlayerGstreamerClass PlayerGstreamerClass;
typedef struct _PlayerGstreamerPrivate PlayerGstreamerPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _Block1Data Block1Data;
#define _fso_device_playing_sound_unref0(var) ((var == NULL) ? NULL : (var = (fso_device_playing_sound_unref (var), NULL)))
typedef struct _Block2Data Block2Data;
typedef struct _PlayerGstreamerPlaySoundData PlayerGstreamerPlaySoundData;
typedef struct _Block3Data Block3Data;
typedef struct _PlayerGstreamerStopAllSoundsData PlayerGstreamerStopAllSoundsData;
typedef struct _PlayerGstreamerStopSoundData PlayerGstreamerStopSoundData;

struct _PlayerGstreamer {
	FsoDeviceBaseAudioPlayer parent_instance;
	PlayerGstreamerPrivate * priv;
};

struct _PlayerGstreamerClass {
	FsoDeviceBaseAudioPlayerClass parent_class;
};

struct _PlayerGstreamerPrivate {
	GeeHashMap* decoders;
	GeeHashMap* pipelines;
};

struct _Block1Data {
	int _ref_count_;
	PlayerGstreamer * self;
	FsoDevicePlayingSound* sound;
};

struct _Block2Data {
	int _ref_count_;
	PlayerGstreamer * self;
	FsoDevicePlayingSound* sound;
	gpointer _async_data_;
};

struct _PlayerGstreamerPlaySoundData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	PlayerGstreamer* self;
	gchar* name;
	gint loop;
	gint length;
	Block2Data* _data2_;
	GeeHashMap* _tmp0_;
	const gchar* _tmp1_;
	gpointer _tmp2_;
	FsoDevicePlayingSound* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	GError* _tmp7_;
	GError* _tmp8_;
	const gchar* _tmp9_;
	gchar** _tmp10_;
	gchar** _tmp11_;
	gchar** parts;
	gint parts_length1;
	gint _parts_size_;
	GError* _tmp12_;
	const gchar* _tmp13_;
	gchar* _tmp14_;
	gchar* extension;
	GeeHashMap* _tmp15_;
	const gchar* _tmp16_;
	gpointer _tmp17_;
	gchar* decoder;
	const gchar* _tmp18_;
	const gchar* _tmp19_;
	const gchar* _tmp20_;
	const gchar* _tmp21_;
	const gchar* _tmp22_;
	gchar* _tmp23_;
	gchar* _tmp24_;
	GstElement* _tmp25_;
	GstElement* _tmp26_;
	GstElement* _tmp27_;
	GstPipeline* pipeline;
	const gchar* _tmp28_;
	gint _tmp29_;
	gint _tmp30_;
	GstPipeline* _tmp31_;
	FsoDevicePlayingSound* _tmp32_;
	GstPipeline* _tmp33_;
	GstBus* _tmp34_;
	GstBus* bus;
	GstBus* _tmp35_;
	GstPipeline* _tmp36_;
	GeeHashMap* _tmp37_;
	const gchar* _tmp38_;
	GstPipeline* _tmp39_;
	GeeHashMap* _tmp40_;
	const gchar* _tmp41_;
	FsoDevicePlayingSound* _tmp42_;
	GError* e;
	FsoFrameworkLogger* _tmp43_;
	GError* _tmp44_;
	const gchar* _tmp45_;
	const gchar* _tmp46_;
	gchar* _tmp47_;
	gchar* _tmp48_;
	GError * _inner_error_;
};

struct _Block3Data {
	int _ref_count_;
	PlayerGstreamer * self;
	FsoDevicePlayingSound* sound;
};

struct _PlayerGstreamerStopAllSoundsData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	PlayerGstreamer* self;
	GeeHashMap* _tmp0_;
	GeeCollection* _tmp1_;
	GeeCollection* _tmp2_;
	GeeCollection* _tmp3_;
	GeeIterator* _tmp4_;
	GeeIterator* _tmp5_;
	GeeIterator* _sound_it;
	Block3Data* _data3_;
	GeeIterator* _tmp6_;
	gboolean _tmp7_;
	GeeIterator* _tmp8_;
	gpointer _tmp9_;
};

struct _PlayerGstreamerStopSoundData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	PlayerGstreamer* self;
	gchar* name;
	GeeHashMap* _tmp0_;
	const gchar* _tmp1_;
	gpointer _tmp2_;
	FsoDevicePlayingSound* sound;
	FsoDevicePlayingSound* _tmp3_;
	FsoDevicePlayingSound* _tmp4_;
};


static gpointer player_gstreamer_parent_class = NULL;
static GType player_gstreamer_type_id = 0;

GType player_gstreamer_get_type (void) G_GNUC_CONST;
GType player_gstreamer_register_type (GTypeModule * module);
#define PLAYER_GSTREAMER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), PLAYER_TYPE_GSTREAMER, PlayerGstreamerPrivate))
enum  {
	PLAYER_GSTREAMER_DUMMY_PROPERTY
};
#define PLAYER_GSTREAMER_FORCED_STOP 42
static gboolean player_gstreamer_trySetupDecoder (PlayerGstreamer* self, const gchar* extension, const gchar* decoder);
static gboolean player_gstreamer_onGstreamerMessage (PlayerGstreamer* self, GstBus* bus, GstMessage* message, FsoDevicePlayingSound* sound);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (Block1Data* _data1_);
static void player_gstreamer_stop (PlayerGstreamer* self, FsoDevicePlayingSound* sound);
static gboolean ______lambda0_ (Block1Data* _data1_);
static gboolean _______lambda0__gsource_func (gpointer self);
static gchar** player_gstreamer_real_supportedFormats (FsoDeviceBaseAudioPlayer* base, int* result_length1);
static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value);
static void player_gstreamer_real_play_sound_data_free (gpointer _data);
static void player_gstreamer_real_play_sound (FsoDeviceBaseAudioPlayer* base, const gchar* name, gint loop, gint length, GAsyncReadyCallback _callback_, gpointer _user_data_);
static gboolean player_gstreamer_real_play_sound_co (PlayerGstreamerPlaySoundData* _data_);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (Block2Data* _data2_);
static gboolean ___lambda1_ (Block2Data* _data2_, GstBus* bus, GstMessage* message);
static gboolean ____lambda1__gst_bus_func (GstBus* bus, GstMessage* message, gpointer self);
static void player_gstreamer_real_stop_all_sounds_data_free (gpointer _data);
static void player_gstreamer_real_stop_all_sounds (FsoDeviceBaseAudioPlayer* base, GAsyncReadyCallback _callback_, gpointer _user_data_);
static gboolean player_gstreamer_real_stop_all_sounds_co (PlayerGstreamerStopAllSoundsData* _data_);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (Block3Data* _data3_);
static gboolean ____lambda2_ (Block3Data* _data3_);
static gboolean _____lambda2__gsource_func (gpointer self);
static void player_gstreamer_real_stop_sound_data_free (gpointer _data);
static void player_gstreamer_real_stop_sound (FsoDeviceBaseAudioPlayer* base, const gchar* name, GAsyncReadyCallback _callback_, gpointer _user_data_);
static gboolean player_gstreamer_real_stop_sound_co (PlayerGstreamerStopSoundData* _data_);
PlayerGstreamer* player_gstreamer_new (void);
PlayerGstreamer* player_gstreamer_construct (GType object_type);
static GObject * player_gstreamer_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void player_gstreamer_finalize (GObject* obj);
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error);
void fso_register_function (GTypeModule* module);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static gboolean player_gstreamer_trySetupDecoder (PlayerGstreamer* self, const gchar* extension, const gchar* decoder) {
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (extension != NULL, FALSE);
	g_return_val_if_fail (decoder != NULL, FALSE);
	{
		const gchar* _tmp0_;
		GstElement* _tmp1_ = NULL;
		GstElement* _tmp2_;
		GeeHashMap* _tmp3_;
		const gchar* _tmp4_;
		const gchar* _tmp5_;
		_tmp0_ = decoder;
		_tmp1_ = gst_parse_bin_from_description (_tmp0_, FALSE, &_inner_error_);
		_tmp2_ = _tmp1_;
		_gst_object_unref0 (_tmp2_);
		if (_inner_error_ != NULL) {
			goto __catch0_g_error;
		}
		_tmp3_ = self->priv->decoders;
		_tmp4_ = extension;
		_tmp5_ = decoder;
		gee_abstract_map_set ((GeeAbstractMap*) _tmp3_, _tmp4_, _tmp5_);
		result = TRUE;
		return result;
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		FsoFrameworkLogger* _tmp6_;
		const gchar* _tmp7_;
		const gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp6_ = fso_framework_theLogger;
		_tmp7_ = decoder;
		_tmp8_ = string_to_string (_tmp7_);
		_tmp9_ = g_strconcat ("Gstreamer does not understand ", _tmp8_, "; not adding to map", NULL);
		_tmp10_ = _tmp9_;
		fso_framework_logger_warning (_tmp6_, _tmp10_);
		_g_free0 (_tmp10_);
		result = FALSE;
		_g_error_free0 (e);
		return result;
	}
	__finally0:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return FALSE;
}


static gpointer _fso_device_playing_sound_ref0 (gpointer self) {
	return self ? fso_device_playing_sound_ref (self) : NULL;
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (Block1Data* _data1_) {
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		_g_object_unref0 (_data1_->self);
		_fso_device_playing_sound_unref0 (_data1_->sound);
		g_slice_free (Block1Data, _data1_);
	}
}


static gpointer _gst_object_ref0 (gpointer self) {
	return self ? gst_object_ref (self) : NULL;
}


static gboolean ______lambda0_ (Block1Data* _data1_) {
	PlayerGstreamer * self;
	gboolean result = FALSE;
	FsoDevicePlayingSound* _tmp0_;
	self = _data1_->self;
	_tmp0_ = _data1_->sound;
	player_gstreamer_stop (self, _tmp0_);
	result = FALSE;
	return result;
}


static gboolean _______lambda0__gsource_func (gpointer self) {
	gboolean result;
	result = ______lambda0_ (self);
	return result;
}


static gboolean player_gstreamer_onGstreamerMessage (PlayerGstreamer* self, GstBus* bus, GstMessage* message, FsoDevicePlayingSound* sound) {
	gboolean result = FALSE;
	Block1Data* _data1_;
	FsoDevicePlayingSound* _tmp0_;
	FsoDevicePlayingSound* _tmp1_;
	FsoFrameworkLogger* _tmp2_;
	GstMessage* _tmp3_;
	GstMessageType _tmp4_;
	const gchar* _tmp5_ = NULL;
	FsoDevicePlayingSound* _tmp6_;
	const gchar* _tmp7_;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_;
	gboolean _tmp11_ = FALSE;
	FsoDevicePlayingSound* _tmp12_;
	guint32 _tmp13_;
	GstPipeline* _tmp14_;
	GstPipeline* pipeline;
	GstMessage* _tmp15_;
	GstMessageType _tmp16_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (bus != NULL, FALSE);
	g_return_val_if_fail (message != NULL, FALSE);
	g_return_val_if_fail (sound != NULL, FALSE);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_tmp0_ = sound;
	_tmp1_ = _fso_device_playing_sound_ref0 (_tmp0_);
	_data1_->sound = _tmp1_;
	_tmp2_ = fso_framework_theLogger;
	_tmp3_ = message;
	_tmp4_ = _tmp3_->type;
	_tmp5_ = gst_message_type_get_name (_tmp4_);
	_tmp6_ = _data1_->sound;
	_tmp7_ = _tmp6_->name;
	_tmp8_ = string_to_string (_tmp7_);
	_tmp9_ = g_strconcat ("Gstreamer: ", _tmp5_, " for sound ", _tmp8_, NULL);
	_tmp10_ = _tmp9_;
	_tmp11_ = fso_framework_logger_debug (_tmp2_, _tmp10_);
	g_assert (_tmp11_);
	_g_free0 (_tmp10_);
	_tmp12_ = _data1_->sound;
	_tmp13_ = _tmp12_->data;
	_tmp14_ = _gst_object_ref0 (GST_IS_PIPELINE (_tmp13_) ? ((GstPipeline*) _tmp13_) : NULL);
	pipeline = _tmp14_;
	_tmp15_ = message;
	_tmp16_ = _tmp15_->type;
	switch (_tmp16_) {
		case GST_MESSAGE_EOS:
		{
			{
				FsoDevicePlayingSound* _tmp17_;
				gint _tmp18_;
				_tmp17_ = _data1_->sound;
				_tmp18_ = _tmp17_->loop;
				_tmp17_->loop = _tmp18_ - 1;
				if (_tmp18_ > 0) {
					GstPipeline* _tmp19_;
					_tmp19_ = pipeline;
					gst_element_seek_simple ((GstElement*) _tmp19_, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH, (gint64) 0);
				} else {
					FsoDevicePlayingSound* _tmp20_;
					_tmp20_ = _data1_->sound;
					player_gstreamer_stop (self, _tmp20_);
				}
				break;
			}
		}
		case GST_MESSAGE_ERROR:
		{
			{
				GError* e = NULL;
				gchar* debug = NULL;
				GstMessage* _tmp21_;
				GError* _tmp22_ = NULL;
				gchar* _tmp23_ = NULL;
				FsoFrameworkLogger* _tmp24_;
				GError* _tmp25_;
				const gchar* _tmp26_;
				const gchar* _tmp27_ = NULL;
				const gchar* _tmp28_;
				const gchar* _tmp29_ = NULL;
				gchar* _tmp30_ = NULL;
				gchar* _tmp31_;
				_tmp21_ = message;
				gst_message_parse_error (_tmp21_, &_tmp22_, &_tmp23_);
				_g_error_free0 (e);
				e = _tmp22_;
				_g_free0 (debug);
				debug = _tmp23_;
				_tmp24_ = fso_framework_theLogger;
				_tmp25_ = e;
				_tmp26_ = _tmp25_->message;
				_tmp27_ = string_to_string (_tmp26_);
				_tmp28_ = debug;
				_tmp29_ = string_to_string (_tmp28_);
				_tmp30_ = g_strconcat ("Gstreamer: Error ", _tmp27_, ": ", _tmp29_, NULL);
				_tmp31_ = _tmp30_;
				fso_framework_logger_warning (_tmp24_, _tmp31_);
				_g_free0 (_tmp31_);
				_g_free0 (debug);
				_g_error_free0 (e);
				break;
			}
		}
		case GST_MESSAGE_STATE_CHANGED:
		{
			{
				GstState previous = 0;
				GstState current = 0;
				GstState pending = 0;
				GstMessage* _tmp32_;
				GstState _tmp33_ = 0;
				GstState _tmp34_ = 0;
				GstState _tmp35_ = 0;
				gboolean _tmp36_ = FALSE;
				gboolean _tmp37_ = FALSE;
				GstState _tmp38_;
				gboolean _tmp40_;
				gboolean _tmp42_;
				_tmp32_ = message;
				gst_message_parse_state_changed (_tmp32_, &_tmp33_, &_tmp34_, &_tmp35_);
				previous = _tmp33_;
				current = _tmp34_;
				pending = _tmp35_;
				_tmp38_ = previous;
				if (_tmp38_ == GST_STATE_READY) {
					GstState _tmp39_;
					_tmp39_ = current;
					_tmp37_ = _tmp39_ == GST_STATE_PAUSED;
				} else {
					_tmp37_ = FALSE;
				}
				_tmp40_ = _tmp37_;
				if (_tmp40_) {
					GstState _tmp41_;
					_tmp41_ = pending;
					_tmp36_ = _tmp41_ == GST_STATE_PLAYING;
				} else {
					_tmp36_ = FALSE;
				}
				_tmp42_ = _tmp36_;
				if (_tmp42_) {
					FsoDevicePlayingSound* _tmp43_;
					gint _tmp44_;
					_tmp43_ = _data1_->sound;
					_tmp44_ = _tmp43_->length;
					if (_tmp44_ > 0) {
						FsoDevicePlayingSound* _tmp45_;
						gint _tmp46_;
						_tmp45_ = _data1_->sound;
						_tmp46_ = _tmp45_->length;
						g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, (guint) _tmp46_, _______lambda0__gsource_func, block1_data_ref (_data1_), block1_data_unref);
					}
				} else {
					gboolean _tmp47_ = FALSE;
					gboolean _tmp48_ = FALSE;
					GstState _tmp49_;
					gboolean _tmp51_;
					gboolean _tmp53_;
					_tmp49_ = previous;
					if (_tmp49_ == GST_STATE_PLAYING) {
						GstState _tmp50_;
						_tmp50_ = current;
						_tmp48_ = _tmp50_ == GST_STATE_PAUSED;
					} else {
						_tmp48_ = FALSE;
					}
					_tmp51_ = _tmp48_;
					if (_tmp51_) {
						GstState _tmp52_;
						_tmp52_ = pending;
						_tmp47_ = _tmp52_ == GST_STATE_READY;
					} else {
						_tmp47_ = FALSE;
					}
					_tmp53_ = _tmp47_;
					if (_tmp53_) {
						FsoDevicePlayingSound* _tmp54_;
						_tmp54_ = _data1_->sound;
						player_gstreamer_stop (self, _tmp54_);
					} else {
					}
				}
				break;
			}
		}
		default:
		{
			{
				FsoFrameworkLogger* _tmp55_;
				GstMessage* _tmp56_;
				GstMessageType _tmp57_;
				const gchar* _tmp58_ = NULL;
				gchar* _tmp59_ = NULL;
				gchar* _tmp60_;
				_tmp55_ = fso_framework_theLogger;
				_tmp56_ = message;
				_tmp57_ = _tmp56_->type;
				_tmp58_ = gst_message_type_get_name (_tmp57_);
				_tmp59_ = g_strconcat ("Gstreamer: Unhandled message w/ type ", _tmp58_, NULL);
				_tmp60_ = _tmp59_;
				fso_framework_logger_warning (_tmp55_, _tmp60_);
				_g_free0 (_tmp60_);
				break;
			}
		}
	}
	result = TRUE;
	_gst_object_unref0 (pipeline);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return result;
}


static void player_gstreamer_stop (PlayerGstreamer* self, FsoDevicePlayingSound* sound) {
	FsoDevicePlayingSound* _tmp0_;
	guint32 _tmp1_;
	GstPipeline* _tmp2_;
	GstPipeline* pipeline;
	GeeHashMap* _tmp3_;
	FsoDevicePlayingSound* _tmp4_;
	const gchar* _tmp5_;
	GeeHashMap* _tmp6_;
	FsoDevicePlayingSound* _tmp7_;
	const gchar* _tmp8_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sound != NULL);
	_tmp0_ = sound;
	_tmp1_ = _tmp0_->data;
	_tmp2_ = _gst_object_ref0 (GST_IS_PIPELINE (_tmp1_) ? ((GstPipeline*) _tmp1_) : NULL);
	pipeline = _tmp2_;
	gst_element_set_state ((GstElement*) pipeline, GST_STATE_NULL);
	_tmp3_ = ((FsoDeviceBaseAudioPlayer*) self)->sounds;
	_tmp4_ = sound;
	_tmp5_ = _tmp4_->name;
	gee_map_remove ((GeeMap*) _tmp3_, _tmp5_, NULL);
	_tmp6_ = self->priv->pipelines;
	_tmp7_ = sound;
	_tmp8_ = _tmp7_->name;
	gee_map_remove ((GeeMap*) _tmp6_, _tmp8_, NULL);
	_gst_object_unref0 (pipeline);
}


static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static gchar** player_gstreamer_real_supportedFormats (FsoDeviceBaseAudioPlayer* base, int* result_length1) {
	PlayerGstreamer * self;
	gchar** result = NULL;
	gchar** _tmp0_ = NULL;
	gchar** keys;
	gint keys_length1;
	gint _keys_size_;
	gchar** _tmp14_;
	gint _tmp14__length1;
	self = (PlayerGstreamer*) base;
	_tmp0_ = g_new0 (gchar*, 0 + 1);
	keys = _tmp0_;
	keys_length1 = 0;
	_keys_size_ = keys_length1;
	{
		GeeHashMap* _tmp1_;
		GeeSet* _tmp2_;
		GeeSet* _tmp3_;
		GeeSet* _tmp4_;
		GeeIterator* _tmp5_ = NULL;
		GeeIterator* _tmp6_;
		GeeIterator* _key_it;
		_tmp1_ = self->priv->decoders;
		_tmp2_ = gee_abstract_map_get_keys ((GeeMap*) _tmp1_);
		_tmp3_ = _tmp2_;
		_tmp4_ = _tmp3_;
		_tmp5_ = gee_iterable_iterator ((GeeIterable*) _tmp4_);
		_tmp6_ = _tmp5_;
		_g_object_unref0 (_tmp4_);
		_key_it = _tmp6_;
		while (TRUE) {
			GeeIterator* _tmp7_;
			gboolean _tmp8_ = FALSE;
			GeeIterator* _tmp9_;
			gpointer _tmp10_ = NULL;
			gchar* key;
			gchar** _tmp11_;
			gint _tmp11__length1;
			const gchar* _tmp12_;
			gchar* _tmp13_;
			_tmp7_ = _key_it;
			_tmp8_ = gee_iterator_next (_tmp7_);
			if (!_tmp8_) {
				break;
			}
			_tmp9_ = _key_it;
			_tmp10_ = gee_iterator_get (_tmp9_);
			key = (gchar*) _tmp10_;
			_tmp11_ = keys;
			_tmp11__length1 = keys_length1;
			_tmp12_ = key;
			_tmp13_ = g_strdup (_tmp12_);
			_vala_array_add1 (&keys, &keys_length1, &_keys_size_, _tmp13_);
			_g_free0 (key);
		}
		_g_object_unref0 (_key_it);
	}
	_tmp14_ = keys;
	_tmp14__length1 = keys_length1;
	if (result_length1) {
		*result_length1 = _tmp14__length1;
	}
	result = _tmp14_;
	return result;
}


static void player_gstreamer_real_play_sound_data_free (gpointer _data) {
	PlayerGstreamerPlaySoundData* _data_;
	_data_ = _data;
	_g_free0 (_data_->name);
	_g_object_unref0 (_data_->self);
	g_slice_free (PlayerGstreamerPlaySoundData, _data_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void player_gstreamer_real_play_sound (FsoDeviceBaseAudioPlayer* base, const gchar* name, gint loop, gint length, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	PlayerGstreamer * self;
	PlayerGstreamerPlaySoundData* _data_;
	PlayerGstreamer* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	self = (PlayerGstreamer*) base;
	_data_ = g_slice_new0 (PlayerGstreamerPlaySoundData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, player_gstreamer_real_play_sound);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, player_gstreamer_real_play_sound_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = name;
	_tmp2_ = g_strdup (_tmp1_);
	_data_->name = _tmp2_;
	_tmp3_ = loop;
	_data_->loop = _tmp3_;
	_tmp4_ = length;
	_data_->length = _tmp4_;
	player_gstreamer_real_play_sound_co (_data_);
}


static void player_gstreamer_real_play_sound_finish (FsoDeviceBaseAudioPlayer* base, GAsyncResult* _res_, GError** error) {
	PlayerGstreamerPlaySoundData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (Block2Data* _data2_) {
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		_g_object_unref0 (_data2_->self);
		_fso_device_playing_sound_unref0 (_data2_->sound);
		g_slice_free (Block2Data, _data2_);
	}
}


static gboolean ___lambda1_ (Block2Data* _data2_, GstBus* bus, GstMessage* message) {
	PlayerGstreamer * self;
	gboolean result = FALSE;
	GstBus* _tmp0_;
	GstMessage* _tmp1_;
	FsoDevicePlayingSound* _tmp2_;
	gboolean _tmp3_ = FALSE;
	self = _data2_->self;
	g_return_val_if_fail (bus != NULL, FALSE);
	g_return_val_if_fail (message != NULL, FALSE);
	g_assert (self != NULL);
	_tmp0_ = bus;
	_tmp1_ = message;
	_tmp2_ = _data2_->sound;
	_tmp3_ = player_gstreamer_onGstreamerMessage (self, _tmp0_, _tmp1_, _tmp2_);
	result = _tmp3_;
	return result;
}


static gboolean ____lambda1__gst_bus_func (GstBus* bus, GstMessage* message, gpointer self) {
	gboolean result;
	result = ___lambda1_ (self, bus, message);
	return result;
}


static gboolean player_gstreamer_real_play_sound_co (PlayerGstreamerPlaySoundData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_data2_ = g_slice_new0 (Block2Data);
	_data_->_data2_->_ref_count_ = 1;
	_data_->_data2_->self = g_object_ref (_data_->self);
	_data_->_data2_->_async_data_ = _data_;
	_data_->_tmp0_ = ((FsoDeviceBaseAudioPlayer*) _data_->self)->sounds;
	_data_->_tmp1_ = _data_->name;
	_data_->_tmp2_ = NULL;
	_data_->_tmp2_ = gee_abstract_map_get ((GeeAbstractMap*) _data_->_tmp0_, _data_->_tmp1_);
	_data_->_data2_->sound = (FsoDevicePlayingSound*) _data_->_tmp2_;
	_data_->_tmp3_ = _data_->_data2_->sound;
	if (_data_->_tmp3_ != NULL) {
		_data_->_tmp4_ = _data_->name;
		_data_->_tmp5_ = NULL;
		_data_->_tmp5_ = g_strdup_printf ("%s is already playing", _data_->_tmp4_);
		_data_->_tmp6_ = _data_->_tmp5_;
		_data_->_tmp7_ = g_error_new_literal (FREE_SMARTPHONE_DEVICE_AUDIO_ERROR, FREE_SMARTPHONE_DEVICE_AUDIO_ERROR_ALREADY_PLAYING, _data_->_tmp6_);
		_data_->_tmp8_ = _data_->_tmp7_;
		_g_free0 (_data_->_tmp6_);
		_data_->_inner_error_ = _data_->_tmp8_;
		if ((_data_->_inner_error_->domain == FREE_SMARTPHONE_DEVICE_AUDIO_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			block2_data_unref (_data_->_data2_);
			_data_->_data2_ = NULL;
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			block2_data_unref (_data_->_data2_);
			_data_->_data2_ = NULL;
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_data_->_tmp9_ = _data_->name;
	_data_->_tmp11_ = NULL;
	_data_->_tmp11_ = _data_->_tmp10_ = g_strsplit (_data_->_tmp9_, ".", 0);
	_data_->parts = _data_->_tmp11_;
	_data_->parts_length1 = _vala_array_length (_data_->_tmp10_);
	_data_->_parts_size_ = _data_->parts_length1;
	if (_data_->parts_length1 == 0) {
		_data_->_tmp12_ = g_error_new_literal (FREE_SMARTPHONE_ERROR, FREE_SMARTPHONE_ERROR_INVALID_PARAMETER, "Could not guess media format; need an extension");
		_data_->_inner_error_ = _data_->_tmp12_;
		if ((_data_->_inner_error_->domain == FREE_SMARTPHONE_DEVICE_AUDIO_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			_data_->parts = (_vala_array_free (_data_->parts, _data_->parts_length1, (GDestroyNotify) g_free), NULL);
			block2_data_unref (_data_->_data2_);
			_data_->_data2_ = NULL;
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			_data_->parts = (_vala_array_free (_data_->parts, _data_->parts_length1, (GDestroyNotify) g_free), NULL);
			block2_data_unref (_data_->_data2_);
			_data_->_data2_ = NULL;
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_data_->_tmp13_ = _data_->parts[_data_->parts_length1 - 1];
	_data_->_tmp14_ = g_strdup (_data_->_tmp13_);
	_data_->extension = _data_->_tmp14_;
	_data_->_tmp15_ = _data_->self->priv->decoders;
	_data_->_tmp16_ = _data_->extension;
	_data_->_tmp17_ = NULL;
	_data_->_tmp17_ = gee_abstract_map_get ((GeeAbstractMap*) _data_->_tmp15_, _data_->_tmp16_);
	_data_->decoder = (gchar*) _data_->_tmp17_;
	_data_->_tmp18_ = _data_->decoder;
	g_assert (_data_->_tmp18_ != NULL);
	g_assert (_data_->self != NULL);
	{
		_data_->_tmp19_ = _data_->name;
		_data_->_tmp20_ = NULL;
		_data_->_tmp20_ = string_to_string (_data_->_tmp19_);
		_data_->_tmp21_ = _data_->decoder;
		_data_->_tmp22_ = NULL;
		_data_->_tmp22_ = string_to_string (_data_->_tmp21_);
		_data_->_tmp23_ = NULL;
		_data_->_tmp23_ = g_strconcat ("filesrc location=\"", _data_->_tmp20_, "\" ! ", _data_->_tmp22_, " ! alsasink", NULL);
		_data_->_tmp24_ = _data_->_tmp23_;
		_data_->_tmp25_ = NULL;
		_data_->_tmp25_ = gst_parse_launch (_data_->_tmp24_, &_data_->_inner_error_);
		_data_->_tmp26_ = _data_->_tmp25_;
		_g_free0 (_data_->_tmp24_);
		_data_->_tmp27_ = _data_->_tmp26_;
		if (_data_->_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
		_data_->pipeline = GST_IS_PIPELINE (_data_->_tmp27_) ? ((GstPipeline*) _data_->_tmp27_) : NULL;
		_data_->_tmp28_ = _data_->name;
		_data_->_tmp29_ = _data_->loop;
		_data_->_tmp30_ = _data_->length;
		_data_->_tmp31_ = _data_->pipeline;
		_data_->_tmp32_ = fso_device_playing_sound_new (_data_->_tmp28_, _data_->_tmp29_, _data_->_tmp30_, (guint32) _data_->_tmp31_);
		_fso_device_playing_sound_unref0 (_data_->_data2_->sound);
		_data_->_data2_->sound = _data_->_tmp32_;
		_data_->_tmp33_ = _data_->pipeline;
		_data_->_tmp34_ = NULL;
		_data_->_tmp34_ = gst_pipeline_get_bus (_data_->_tmp33_);
		_data_->bus = _data_->_tmp34_;
		_data_->_tmp35_ = _data_->bus;
		gst_bus_add_watch_full (_data_->_tmp35_, 0, ____lambda1__gst_bus_func, block2_data_ref (_data_->_data2_), block2_data_unref);
		_data_->_tmp36_ = _data_->pipeline;
		gst_element_set_state ((GstElement*) _data_->_tmp36_, GST_STATE_PLAYING);
		_data_->_tmp37_ = _data_->self->priv->pipelines;
		_data_->_tmp38_ = _data_->name;
		_data_->_tmp39_ = _data_->pipeline;
		gee_abstract_map_set ((GeeAbstractMap*) _data_->_tmp37_, _data_->_tmp38_, _data_->_tmp39_);
		_data_->_tmp40_ = ((FsoDeviceBaseAudioPlayer*) _data_->self)->sounds;
		_data_->_tmp41_ = _data_->name;
		_data_->_tmp42_ = _data_->_data2_->sound;
		gee_abstract_map_set ((GeeAbstractMap*) _data_->_tmp40_, _data_->_tmp41_, _data_->_tmp42_);
		_gst_object_unref0 (_data_->bus);
		_gst_object_unref0 (_data_->pipeline);
	}
	goto __finally1;
	__catch1_g_error:
	{
		_data_->e = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp43_ = fso_framework_theLogger;
		_data_->_tmp44_ = _data_->e;
		_data_->_tmp45_ = _data_->_tmp44_->message;
		_data_->_tmp46_ = NULL;
		_data_->_tmp46_ = string_to_string (_data_->_tmp45_);
		_data_->_tmp47_ = NULL;
		_data_->_tmp47_ = g_strconcat ("Could not create/launch GStreamer pipeline: ", _data_->_tmp46_, NULL);
		_data_->_tmp48_ = _data_->_tmp47_;
		fso_framework_logger_warning (_data_->_tmp43_, _data_->_tmp48_);
		_g_free0 (_data_->_tmp48_);
		_g_error_free0 (_data_->e);
		_g_free0 (_data_->decoder);
		_g_free0 (_data_->extension);
		_data_->parts = (_vala_array_free (_data_->parts, _data_->parts_length1, (GDestroyNotify) g_free), NULL);
		block2_data_unref (_data_->_data2_);
		_data_->_data2_ = NULL;
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	__finally1:
	if (_data_->_inner_error_ != NULL) {
		if ((_data_->_inner_error_->domain == FREE_SMARTPHONE_DEVICE_AUDIO_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			_g_free0 (_data_->decoder);
			_g_free0 (_data_->extension);
			_data_->parts = (_vala_array_free (_data_->parts, _data_->parts_length1, (GDestroyNotify) g_free), NULL);
			block2_data_unref (_data_->_data2_);
			_data_->_data2_ = NULL;
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			_g_free0 (_data_->decoder);
			_g_free0 (_data_->extension);
			_data_->parts = (_vala_array_free (_data_->parts, _data_->parts_length1, (GDestroyNotify) g_free), NULL);
			block2_data_unref (_data_->_data2_);
			_data_->_data2_ = NULL;
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_g_free0 (_data_->decoder);
	_g_free0 (_data_->extension);
	_data_->parts = (_vala_array_free (_data_->parts, _data_->parts_length1, (GDestroyNotify) g_free), NULL);
	block2_data_unref (_data_->_data2_);
	_data_->_data2_ = NULL;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void player_gstreamer_real_stop_all_sounds_data_free (gpointer _data) {
	PlayerGstreamerStopAllSoundsData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (PlayerGstreamerStopAllSoundsData, _data_);
}


static void player_gstreamer_real_stop_all_sounds (FsoDeviceBaseAudioPlayer* base, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	PlayerGstreamer * self;
	PlayerGstreamerStopAllSoundsData* _data_;
	PlayerGstreamer* _tmp0_;
	self = (PlayerGstreamer*) base;
	_data_ = g_slice_new0 (PlayerGstreamerStopAllSoundsData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, player_gstreamer_real_stop_all_sounds);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, player_gstreamer_real_stop_all_sounds_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	player_gstreamer_real_stop_all_sounds_co (_data_);
}


static void player_gstreamer_real_stop_all_sounds_finish (FsoDeviceBaseAudioPlayer* base, GAsyncResult* _res_) {
	PlayerGstreamerStopAllSoundsData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static Block3Data* block3_data_ref (Block3Data* _data3_) {
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}


static void block3_data_unref (Block3Data* _data3_) {
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		_g_object_unref0 (_data3_->self);
		_fso_device_playing_sound_unref0 (_data3_->sound);
		g_slice_free (Block3Data, _data3_);
	}
}


static gboolean ____lambda2_ (Block3Data* _data3_) {
	PlayerGstreamer * self;
	gboolean result = FALSE;
	FsoDevicePlayingSound* _tmp0_;
	self = _data3_->self;
	_tmp0_ = _data3_->sound;
	player_gstreamer_stop (self, _tmp0_);
	result = FALSE;
	return result;
}


static gboolean _____lambda2__gsource_func (gpointer self) {
	gboolean result;
	result = ____lambda2_ (self);
	return result;
}


static gboolean player_gstreamer_real_stop_all_sounds_co (PlayerGstreamerStopAllSoundsData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	{
		_data_->_tmp0_ = ((FsoDeviceBaseAudioPlayer*) _data_->self)->sounds;
		_data_->_tmp1_ = gee_abstract_map_get_values ((GeeMap*) _data_->_tmp0_);
		_data_->_tmp2_ = _data_->_tmp1_;
		_data_->_tmp3_ = _data_->_tmp2_;
		_data_->_tmp4_ = NULL;
		_data_->_tmp4_ = gee_iterable_iterator ((GeeIterable*) _data_->_tmp3_);
		_data_->_tmp5_ = _data_->_tmp4_;
		_g_object_unref0 (_data_->_tmp3_);
		_data_->_sound_it = _data_->_tmp5_;
		while (TRUE) {
			_data_->_data3_ = g_slice_new0 (Block3Data);
			_data_->_data3_->_ref_count_ = 1;
			_data_->_data3_->self = g_object_ref (_data_->self);
			_data_->_tmp6_ = _data_->_sound_it;
			_data_->_tmp7_ = FALSE;
			_data_->_tmp7_ = gee_iterator_next (_data_->_tmp6_);
			if (!_data_->_tmp7_) {
				block3_data_unref (_data_->_data3_);
				_data_->_data3_ = NULL;
				break;
			}
			_data_->_tmp8_ = _data_->_sound_it;
			_data_->_tmp9_ = NULL;
			_data_->_tmp9_ = gee_iterator_get (_data_->_tmp8_);
			_data_->_data3_->sound = (FsoDevicePlayingSound*) _data_->_tmp9_;
			g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _____lambda2__gsource_func, block3_data_ref (_data_->_data3_), block3_data_unref);
			block3_data_unref (_data_->_data3_);
			_data_->_data3_ = NULL;
		}
		_g_object_unref0 (_data_->_sound_it);
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void player_gstreamer_real_stop_sound_data_free (gpointer _data) {
	PlayerGstreamerStopSoundData* _data_;
	_data_ = _data;
	_g_free0 (_data_->name);
	_g_object_unref0 (_data_->self);
	g_slice_free (PlayerGstreamerStopSoundData, _data_);
}


static void player_gstreamer_real_stop_sound (FsoDeviceBaseAudioPlayer* base, const gchar* name, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	PlayerGstreamer * self;
	PlayerGstreamerStopSoundData* _data_;
	PlayerGstreamer* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	self = (PlayerGstreamer*) base;
	_data_ = g_slice_new0 (PlayerGstreamerStopSoundData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, player_gstreamer_real_stop_sound);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, player_gstreamer_real_stop_sound_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = name;
	_tmp2_ = g_strdup (_tmp1_);
	_data_->name = _tmp2_;
	player_gstreamer_real_stop_sound_co (_data_);
}


static void player_gstreamer_real_stop_sound_finish (FsoDeviceBaseAudioPlayer* base, GAsyncResult* _res_, GError** error) {
	PlayerGstreamerStopSoundData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static gboolean player_gstreamer_real_stop_sound_co (PlayerGstreamerStopSoundData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = ((FsoDeviceBaseAudioPlayer*) _data_->self)->sounds;
	_data_->_tmp1_ = _data_->name;
	_data_->_tmp2_ = NULL;
	_data_->_tmp2_ = gee_abstract_map_get ((GeeAbstractMap*) _data_->_tmp0_, _data_->_tmp1_);
	_data_->sound = (FsoDevicePlayingSound*) _data_->_tmp2_;
	_data_->_tmp3_ = _data_->sound;
	if (_data_->_tmp3_ == NULL) {
		_fso_device_playing_sound_unref0 (_data_->sound);
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp4_ = _data_->sound;
	player_gstreamer_stop (_data_->self, _data_->_tmp4_);
	_fso_device_playing_sound_unref0 (_data_->sound);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


PlayerGstreamer* player_gstreamer_construct (GType object_type) {
	PlayerGstreamer * self = NULL;
	self = (PlayerGstreamer*) fso_device_base_audio_player_construct (object_type);
	return self;
}


PlayerGstreamer* player_gstreamer_new (void) {
	return player_gstreamer_construct (PLAYER_TYPE_GSTREAMER);
}


static GObject * player_gstreamer_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	PlayerGstreamer * self;
	GeeHashMap* _tmp0_;
	gboolean _tmp1_ = FALSE;
	gboolean haveIt;
	gboolean _tmp2_;
	GeeHashMap* _tmp3_;
	parent_class = G_OBJECT_CLASS (player_gstreamer_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = PLAYER_GSTREAMER (obj);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->decoders);
	self->priv->decoders = _tmp0_;
	player_gstreamer_trySetupDecoder (self, "mod", "modplug");
	player_gstreamer_trySetupDecoder (self, "mp3", "mad");
	player_gstreamer_trySetupDecoder (self, "sid", "siddec");
	player_gstreamer_trySetupDecoder (self, "wav", "wavparse");
	_tmp1_ = player_gstreamer_trySetupDecoder (self, "ogg", "oggdemux ! ivorbisdec ! audioconvert");
	haveIt = _tmp1_;
	_tmp2_ = haveIt;
	if (!_tmp2_) {
		player_gstreamer_trySetupDecoder (self, "ogg", "oggdemux ! vorbisdec ! audioconvert");
	}
	_tmp3_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, GST_TYPE_PIPELINE, (GBoxedCopyFunc) gst_object_ref, gst_object_unref, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->pipelines);
	self->priv->pipelines = _tmp3_;
	return obj;
}


static void player_gstreamer_class_init (PlayerGstreamerClass * klass) {
	player_gstreamer_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PlayerGstreamerPrivate));
	FSO_DEVICE_BASE_AUDIO_PLAYER_CLASS (klass)->supportedFormats = player_gstreamer_real_supportedFormats;
	FSO_DEVICE_BASE_AUDIO_PLAYER_CLASS (klass)->play_sound = player_gstreamer_real_play_sound;
	FSO_DEVICE_BASE_AUDIO_PLAYER_CLASS (klass)->play_sound_finish = player_gstreamer_real_play_sound_finish;
	FSO_DEVICE_BASE_AUDIO_PLAYER_CLASS (klass)->stop_all_sounds = player_gstreamer_real_stop_all_sounds;
	FSO_DEVICE_BASE_AUDIO_PLAYER_CLASS (klass)->stop_all_sounds_finish = player_gstreamer_real_stop_all_sounds_finish;
	FSO_DEVICE_BASE_AUDIO_PLAYER_CLASS (klass)->stop_sound = player_gstreamer_real_stop_sound;
	FSO_DEVICE_BASE_AUDIO_PLAYER_CLASS (klass)->stop_sound_finish = player_gstreamer_real_stop_sound_finish;
	G_OBJECT_CLASS (klass)->constructor = player_gstreamer_constructor;
	G_OBJECT_CLASS (klass)->finalize = player_gstreamer_finalize;
}


static void player_gstreamer_instance_init (PlayerGstreamer * self) {
	self->priv = PLAYER_GSTREAMER_GET_PRIVATE (self);
}


static void player_gstreamer_finalize (GObject* obj) {
	PlayerGstreamer * self;
	self = PLAYER_GSTREAMER (obj);
	_g_object_unref0 (self->priv->decoders);
	_g_object_unref0 (self->priv->pipelines);
	G_OBJECT_CLASS (player_gstreamer_parent_class)->finalize (obj);
}


/**
 * AudioPlayer using gstreamer
 **/
GType player_gstreamer_get_type (void) {
	return player_gstreamer_type_id;
}


GType player_gstreamer_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (PlayerGstreamerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) player_gstreamer_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlayerGstreamer), 0, (GInstanceInitFunc) player_gstreamer_instance_init, NULL };
	player_gstreamer_type_id = g_type_module_register_type (module, FSO_DEVICE_TYPE_BASE_AUDIO_PLAYER, "PlayerGstreamer", &g_define_type_info, 0);
	return player_gstreamer_type_id;
}


/**
 * This function gets called on plugin initialization time.
 * @return the name of your plugin here
 * @note that it needs to be a name in the format <subsystem>.<plugin>
 * else your module will be unloaded immediately.
 **/
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error) {
	gchar* result = NULL;
	gchar** args;
	gint args_length1;
	gint _args_size_;
	gchar* _tmp0_;
	g_return_val_if_fail (subsystem != NULL, NULL);
	args = NULL;
	args_length1 = 0;
	_args_size_ = args_length1;
	g_thread_init (NULL);
	gst_init (&args_length1, &args);
	_tmp0_ = g_strdup ("fsodevice.player_gstreamer");
	result = _tmp0_;
	return result;
}


void fso_register_function (GTypeModule* module) {
	FsoFrameworkLogger* _tmp0_;
	g_return_if_fail (module != NULL);
	player_gstreamer_register_type (module);
	_tmp0_ = fso_framework_theLogger;
	fso_framework_logger_debug (_tmp0_, "fsodevice.player_gstreamer fso_register_function()");
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



