/* plugin.c generated by valac 0.14.2, the Vala compiler
 * generated from plugin.vala, do not modify */

/*
 * Copyright (C) 2009-2011 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <fsodevice.h>
#include <fcntl.h>
#include <sys/types.h>
#include <fsobasics.h>
#include <errno.h>
#include <unistd.h>
#include <linux/input.h>
#include <fsoframework.h>


#define HARDWARE_TYPE_ACCELEROMETER_LIS302 (hardware_accelerometer_lis302_get_type ())
#define HARDWARE_ACCELEROMETER_LIS302(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), HARDWARE_TYPE_ACCELEROMETER_LIS302, HardwareAccelerometerLis302))
#define HARDWARE_ACCELEROMETER_LIS302_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), HARDWARE_TYPE_ACCELEROMETER_LIS302, HardwareAccelerometerLis302Class))
#define HARDWARE_IS_ACCELEROMETER_LIS302(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), HARDWARE_TYPE_ACCELEROMETER_LIS302))
#define HARDWARE_IS_ACCELEROMETER_LIS302_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), HARDWARE_TYPE_ACCELEROMETER_LIS302))
#define HARDWARE_ACCELEROMETER_LIS302_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), HARDWARE_TYPE_ACCELEROMETER_LIS302, HardwareAccelerometerLis302Class))

typedef struct _HardwareAccelerometerLis302 HardwareAccelerometerLis302;
typedef struct _HardwareAccelerometerLis302Class HardwareAccelerometerLis302Class;
typedef struct _HardwareAccelerometerLis302Private HardwareAccelerometerLis302Private;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_io_channel_unref0(var) ((var == NULL) ? NULL : (var = (g_io_channel_unref (var), NULL)))

struct _HardwareAccelerometerLis302 {
	FsoDeviceBaseAccelerometer parent_instance;
	HardwareAccelerometerLis302Private * priv;
	gint fd;
};

struct _HardwareAccelerometerLis302Class {
	FsoDeviceBaseAccelerometerClass parent_class;
};

struct _HardwareAccelerometerLis302Private {
	gchar* inputnode;
	gchar* sysfsnode;
	guint duration;
	guint sample_rate;
	guint threshold;
	gchar* full_scale;
	GIOChannel* channel;
	guint watch;
	gint* axis;
	gint axis_length1;
	gint _axis_size_;
};


static gpointer hardware_accelerometer_lis302_parent_class = NULL;
static GType hardware_accelerometer_lis302_type_id = 0;

#define HARDWARE_PLUGIN_NAME "fsodevice.accelerometer_lis302"
#define HARDWARE_DEFAULT_EVENT_NODE "/input/event4"
#define HARDWARE_LIS302_CONFIGURATION_NODE "/bus/spi/devices/spi3.0/"
#define HARDWARE_LIS302_DEFAULT_DURATION 200
#define HARDWARE_LIS302_DEFAULT_SAMPLERATE 100
#define HARDWARE_LIS302_DEFAULT_THRESHOLD 54
#define HARDWARE_LIS302_DEFAULT_FULLSCALE "2.3"
GType hardware_accelerometer_lis302_get_type (void) G_GNUC_CONST;
GType hardware_accelerometer_lis302_register_type (GTypeModule * module);
#define HARDWARE_ACCELEROMETER_LIS302_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), HARDWARE_TYPE_ACCELEROMETER_LIS302, HardwareAccelerometerLis302Private))
enum  {
	HARDWARE_ACCELEROMETER_LIS302_DUMMY_PROPERTY
};
static gchar* hardware_accelerometer_lis302_real_repr (FsoFrameworkAbstractObject* base);
static void hardware_accelerometer_lis302_real_start (FsoDeviceBaseAccelerometer* base);
gboolean hardware_accelerometer_lis302_onInputEvent (HardwareAccelerometerLis302* self, GIOChannel* source, GIOCondition condition);
static gboolean _hardware_accelerometer_lis302_onInputEvent_gio_func (GIOChannel* source, GIOCondition condition, gpointer self);
static void hardware_accelerometer_lis302_real_stop (FsoDeviceBaseAccelerometer* base);
static void _hardware_accelerometer_lis302_handleInputEvent (HardwareAccelerometerLis302* self, struct input_event* ev);
HardwareAccelerometerLis302* hardware_accelerometer_lis302_new (void);
HardwareAccelerometerLis302* hardware_accelerometer_lis302_construct (GType object_type);
static GObject * hardware_accelerometer_lis302_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void hardware_accelerometer_lis302_finalize (GObject* obj);
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error);
void fso_register_function (GTypeModule* module);


static gchar* hardware_accelerometer_lis302_real_repr (FsoFrameworkAbstractObject* base) {
	HardwareAccelerometerLis302 * self;
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	self = (HardwareAccelerometerLis302*) base;
	_tmp0_ = self->priv->inputnode;
	_tmp1_ = g_strdup_printf ("<via %s>", _tmp0_);
	result = _tmp1_;
	return result;
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static gboolean _hardware_accelerometer_lis302_onInputEvent_gio_func (GIOChannel* source, GIOCondition condition, gpointer self) {
	gboolean result;
	result = hardware_accelerometer_lis302_onInputEvent (self, source, condition);
	return result;
}


static void hardware_accelerometer_lis302_real_start (FsoDeviceBaseAccelerometer* base) {
	HardwareAccelerometerLis302 * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_;
	gint _tmp11_;
	GIOChannel* _tmp12_;
	GIOChannel* _tmp13_;
	guint _tmp14_ = 0U;
	self = (HardwareAccelerometerLis302*) base;
	_tmp0_ = self->priv->inputnode;
	_tmp1_ = open (_tmp0_, O_RDONLY, (mode_t) 0);
	self->fd = _tmp1_;
	_tmp2_ = self->fd;
	if (_tmp2_ == (-1)) {
		FsoFrameworkLogger* _tmp3_;
		const gchar* _tmp4_;
		const gchar* _tmp5_ = NULL;
		gint _tmp6_;
		const gchar* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		_tmp3_ = ((FsoFrameworkAbstractObject*) self)->logger;
		_tmp4_ = self->priv->inputnode;
		_tmp5_ = string_to_string (_tmp4_);
		_tmp6_ = errno;
		_tmp7_ = g_strerror (_tmp6_);
		_tmp8_ = string_to_string (_tmp7_);
		_tmp9_ = g_strconcat ("Can't open ", _tmp5_, ": ", _tmp8_, " Lis302 Accelerometer not available.", NULL);
		_tmp10_ = _tmp9_;
		fso_framework_logger_warning (_tmp3_, _tmp10_);
		_g_free0 (_tmp10_);
		return;
	}
	_tmp11_ = self->fd;
	_tmp12_ = g_io_channel_unix_new (_tmp11_);
	_g_io_channel_unref0 (self->priv->channel);
	self->priv->channel = _tmp12_;
	_tmp13_ = self->priv->channel;
	_tmp14_ = g_io_add_watch (_tmp13_, G_IO_IN, _hardware_accelerometer_lis302_onInputEvent_gio_func, self);
	self->priv->watch = _tmp14_;
}


static void hardware_accelerometer_lis302_real_stop (FsoDeviceBaseAccelerometer* base) {
	HardwareAccelerometerLis302 * self;
	guint _tmp0_;
	gint _tmp2_;
	self = (HardwareAccelerometerLis302*) base;
	_tmp0_ = self->priv->watch;
	if (_tmp0_ > ((guint) 0)) {
		guint _tmp1_;
		_tmp1_ = self->priv->watch;
		g_source_remove (_tmp1_);
	}
	_g_io_channel_unref0 (self->priv->channel);
	self->priv->channel = NULL;
	_tmp2_ = self->fd;
	if (_tmp2_ != (-1)) {
		gint _tmp3_;
		_tmp3_ = self->fd;
		close (_tmp3_);
	}
	self->fd = -1;
}


static void _hardware_accelerometer_lis302_handleInputEvent (HardwareAccelerometerLis302* self, struct input_event* ev) {
	struct input_event _tmp0_;
	guint16 _tmp1_;
	gint* _tmp3_;
	gint _tmp3__length1;
	struct input_event _tmp4_;
	guint16 _tmp5_;
	struct input_event _tmp6_;
	gint32 _tmp7_;
	gint _tmp8_;
	gint* _tmp9_;
	gint _tmp9__length1;
	gint _tmp10_;
	gint* _tmp11_;
	gint _tmp11__length1;
	gint _tmp12_;
	gint* _tmp13_;
	gint _tmp13__length1;
	gint _tmp14_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (ev != NULL);
	_tmp0_ = *ev;
	_tmp1_ = _tmp0_.code;
	if (((gint) _tmp1_) > 2) {
		FsoFrameworkLogger* _tmp2_;
		_tmp2_ = ((FsoFrameworkAbstractObject*) self)->logger;
		fso_framework_logger_warning (_tmp2_, "Invalid data from input device. axis > 2");
		return;
	}
	_tmp3_ = self->priv->axis;
	_tmp3__length1 = self->priv->axis_length1;
	_tmp4_ = *ev;
	_tmp5_ = _tmp4_.code;
	_tmp6_ = *ev;
	_tmp7_ = _tmp6_.value;
	_tmp3_[_tmp5_] = (gint) _tmp7_;
	_tmp8_ = _tmp3_[_tmp5_];
	_tmp9_ = self->priv->axis;
	_tmp9__length1 = self->priv->axis_length1;
	_tmp10_ = _tmp9_[0];
	_tmp11_ = self->priv->axis;
	_tmp11__length1 = self->priv->axis_length1;
	_tmp12_ = _tmp11_[1];
	_tmp13_ = self->priv->axis;
	_tmp13__length1 = self->priv->axis_length1;
	_tmp14_ = _tmp13_[2];
	g_signal_emit_by_name ((FsoDeviceBaseAccelerometer*) self, "accelerate", _tmp10_, _tmp12_, _tmp14_);
}


gboolean hardware_accelerometer_lis302_onInputEvent (HardwareAccelerometerLis302* self, GIOChannel* source, GIOCondition condition) {
	gboolean result = FALSE;
	struct input_event _tmp0_ = {0};
	struct input_event ev;
	GIOChannel* _tmp1_;
	gint _tmp2_ = 0;
	gssize _tmp3_ = 0L;
	gssize bytesread;
	gssize _tmp4_;
	struct input_event _tmp10_;
	guint16 _tmp11_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (source != NULL, FALSE);
	ev = _tmp0_;
	_tmp1_ = source;
	_tmp2_ = g_io_channel_unix_get_fd (_tmp1_);
	_tmp3_ = read (_tmp2_, &ev, (gsize) sizeof (struct input_event));
	bytesread = _tmp3_;
	_tmp4_ = bytesread;
	if (_tmp4_ == ((gssize) 0)) {
		FsoFrameworkLogger* _tmp5_;
		GIOChannel* _tmp6_;
		gint _tmp7_ = 0;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_;
		_tmp5_ = ((FsoFrameworkAbstractObject*) self)->logger;
		_tmp6_ = source;
		_tmp7_ = g_io_channel_unix_get_fd (_tmp6_);
		_tmp8_ = g_strdup_printf ("could not read from input device fd %d.", _tmp7_);
		_tmp9_ = _tmp8_;
		fso_framework_logger_warning (_tmp5_, _tmp9_);
		_g_free0 (_tmp9_);
		result = FALSE;
		return result;
	}
	_tmp10_ = ev;
	_tmp11_ = _tmp10_.type;
	if (_tmp11_ == EV_ABS) {
		FsoFrameworkLogger* _tmp12_;
		GIOChannel* _tmp13_;
		gint _tmp14_ = 0;
		struct input_event _tmp15_;
		guint16 _tmp16_;
		struct input_event _tmp17_;
		guint16 _tmp18_;
		struct input_event _tmp19_;
		gint32 _tmp20_;
		gchar* _tmp21_ = NULL;
		gchar* _tmp22_;
		gboolean _tmp23_ = FALSE;
		_tmp12_ = ((FsoFrameworkAbstractObject*) self)->logger;
		_tmp13_ = source;
		_tmp14_ = g_io_channel_unix_get_fd (_tmp13_);
		_tmp15_ = ev;
		_tmp16_ = _tmp15_.type;
		_tmp17_ = ev;
		_tmp18_ = _tmp17_.code;
		_tmp19_ = ev;
		_tmp20_ = _tmp19_.value;
		_tmp21_ = g_strdup_printf ("input ev %d, %d, %d, %d", _tmp14_, (gint) _tmp16_, (gint) _tmp18_, (gint) _tmp20_);
		_tmp22_ = _tmp21_;
		_tmp23_ = fso_framework_logger_debug (_tmp12_, _tmp22_);
		g_assert (_tmp23_);
		_g_free0 (_tmp22_);
		_hardware_accelerometer_lis302_handleInputEvent (self, &ev);
	}
	result = TRUE;
	return result;
}


HardwareAccelerometerLis302* hardware_accelerometer_lis302_construct (GType object_type) {
	HardwareAccelerometerLis302 * self = NULL;
	self = (HardwareAccelerometerLis302*) fso_device_base_accelerometer_construct (object_type);
	return self;
}


HardwareAccelerometerLis302* hardware_accelerometer_lis302_new (void) {
	return hardware_accelerometer_lis302_construct (HARDWARE_TYPE_ACCELEROMETER_LIS302);
}


static GObject * hardware_accelerometer_lis302_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	HardwareAccelerometerLis302 * self;
	FsoFrameworkLogger* _tmp0_;
	FsoFrameworkSmartKeyFile* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* sysfs_root;
	FsoFrameworkSmartKeyFile* _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* devfs_root;
	const gchar* _tmp5_;
	FsoFrameworkSmartKeyFile* _tmp6_;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_;
	gchar* _tmp9_;
	const gchar* _tmp10_;
	FsoFrameworkSmartKeyFile* _tmp11_;
	gchar* _tmp12_ = NULL;
	gchar* _tmp13_;
	gchar* _tmp14_;
	FsoFrameworkSmartKeyFile* _tmp15_;
	gint _tmp16_ = 0;
	FsoFrameworkSmartKeyFile* _tmp17_;
	gint _tmp18_ = 0;
	FsoFrameworkSmartKeyFile* _tmp19_;
	gint _tmp20_ = 0;
	FsoFrameworkSmartKeyFile* _tmp21_;
	gchar* _tmp22_ = NULL;
	const gchar* _tmp23_;
	gboolean _tmp24_ = FALSE;
	gint* _tmp51_ = NULL;
	parent_class = G_OBJECT_CLASS (hardware_accelerometer_lis302_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = HARDWARE_ACCELEROMETER_LIS302 (obj);
	_tmp0_ = ((FsoFrameworkAbstractObject*) self)->logger;
	fso_framework_logger_info (_tmp0_, "Registering lis302 accelerometer");
	_tmp1_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp2_ = fso_framework_smart_key_file_stringValue (_tmp1_, "cornucopia", "sysfs_root", "/sys");
	sysfs_root = _tmp2_;
	_tmp3_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp4_ = fso_framework_smart_key_file_stringValue (_tmp3_, "cornucopia", "devfs_root", "/dev");
	devfs_root = _tmp4_;
	_tmp5_ = devfs_root;
	_tmp6_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp7_ = fso_framework_smart_key_file_stringValue (_tmp6_, HARDWARE_PLUGIN_NAME, "inputnode", HARDWARE_DEFAULT_EVENT_NODE);
	_tmp8_ = _tmp7_;
	_tmp9_ = g_strconcat (_tmp5_, _tmp8_, NULL);
	_g_free0 (self->priv->inputnode);
	self->priv->inputnode = _tmp9_;
	_g_free0 (_tmp8_);
	_tmp10_ = sysfs_root;
	_tmp11_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp12_ = fso_framework_smart_key_file_stringValue (_tmp11_, HARDWARE_PLUGIN_NAME, "sysfsnode", HARDWARE_LIS302_CONFIGURATION_NODE);
	_tmp13_ = _tmp12_;
	_tmp14_ = g_strconcat (_tmp10_, _tmp13_, NULL);
	_g_free0 (self->priv->sysfsnode);
	self->priv->sysfsnode = _tmp14_;
	_g_free0 (_tmp13_);
	_tmp15_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp16_ = fso_framework_smart_key_file_intValue (_tmp15_, HARDWARE_PLUGIN_NAME, "duration", HARDWARE_LIS302_DEFAULT_DURATION);
	self->priv->duration = (guint) _tmp16_;
	_tmp17_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp18_ = fso_framework_smart_key_file_intValue (_tmp17_, HARDWARE_PLUGIN_NAME, "sample_rate", HARDWARE_LIS302_DEFAULT_SAMPLERATE);
	self->priv->sample_rate = (guint) _tmp18_;
	_tmp19_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp20_ = fso_framework_smart_key_file_intValue (_tmp19_, HARDWARE_PLUGIN_NAME, "threshold", HARDWARE_LIS302_DEFAULT_THRESHOLD);
	self->priv->threshold = (guint) _tmp20_;
	_tmp21_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp22_ = fso_framework_smart_key_file_stringValue (_tmp21_, HARDWARE_PLUGIN_NAME, "full_scale", HARDWARE_LIS302_DEFAULT_FULLSCALE);
	_g_free0 (self->priv->full_scale);
	self->priv->full_scale = _tmp22_;
	_tmp23_ = self->priv->sysfsnode;
	_tmp24_ = fso_framework_file_handling_isPresent (_tmp23_);
	if (!_tmp24_) {
		FsoFrameworkLogger* _tmp25_;
		const gchar* _tmp26_;
		gchar* _tmp27_ = NULL;
		gchar* _tmp28_;
		_tmp25_ = ((FsoFrameworkAbstractObject*) self)->logger;
		_tmp26_ = self->priv->sysfsnode;
		_tmp27_ = g_strdup_printf ("Lis302 configuration sysfs not available at %s. Accelerometer will not" \
" work properly.", _tmp26_);
		_tmp28_ = _tmp27_;
		fso_framework_logger_warning (_tmp25_, _tmp28_);
		_g_free0 (_tmp28_);
	} else {
		guint _tmp29_;
		gchar* _tmp30_ = NULL;
		gchar* _tmp31_;
		const gchar* _tmp32_;
		gchar* _tmp33_;
		gchar* _tmp34_;
		guint _tmp35_;
		gchar* _tmp36_ = NULL;
		gchar* _tmp37_;
		const gchar* _tmp38_;
		gchar* _tmp39_;
		gchar* _tmp40_;
		guint _tmp41_;
		gchar* _tmp42_ = NULL;
		gchar* _tmp43_;
		const gchar* _tmp44_;
		gchar* _tmp45_;
		gchar* _tmp46_;
		const gchar* _tmp47_;
		const gchar* _tmp48_;
		gchar* _tmp49_;
		gchar* _tmp50_;
		_tmp29_ = self->priv->duration;
		_tmp30_ = g_strdup_printf ("%u", _tmp29_);
		_tmp31_ = _tmp30_;
		_tmp32_ = self->priv->sysfsnode;
		_tmp33_ = g_strconcat (_tmp32_, "/duration", NULL);
		_tmp34_ = _tmp33_;
		fso_framework_file_handling_write (_tmp31_, _tmp34_, FALSE);
		_g_free0 (_tmp34_);
		_g_free0 (_tmp31_);
		_tmp35_ = self->priv->sample_rate;
		_tmp36_ = g_strdup_printf ("%u", _tmp35_);
		_tmp37_ = _tmp36_;
		_tmp38_ = self->priv->sysfsnode;
		_tmp39_ = g_strconcat (_tmp38_, "/sample_rate", NULL);
		_tmp40_ = _tmp39_;
		fso_framework_file_handling_write (_tmp37_, _tmp40_, FALSE);
		_g_free0 (_tmp40_);
		_g_free0 (_tmp37_);
		_tmp41_ = self->priv->threshold;
		_tmp42_ = g_strdup_printf ("%u", _tmp41_);
		_tmp43_ = _tmp42_;
		_tmp44_ = self->priv->sysfsnode;
		_tmp45_ = g_strconcat (_tmp44_, "/threshold", NULL);
		_tmp46_ = _tmp45_;
		fso_framework_file_handling_write (_tmp43_, _tmp46_, FALSE);
		_g_free0 (_tmp46_);
		_g_free0 (_tmp43_);
		_tmp47_ = self->priv->full_scale;
		_tmp48_ = self->priv->sysfsnode;
		_tmp49_ = g_strconcat (_tmp48_, "/full_scale", NULL);
		_tmp50_ = _tmp49_;
		fso_framework_file_handling_write (_tmp47_, _tmp50_, FALSE);
		_g_free0 (_tmp50_);
	}
	_tmp51_ = g_new0 (gint, 3);
	self->priv->axis = (g_free (self->priv->axis), NULL);
	self->priv->axis = _tmp51_;
	self->priv->axis_length1 = 3;
	self->priv->_axis_size_ = self->priv->axis_length1;
	_g_free0 (devfs_root);
	_g_free0 (sysfs_root);
	return obj;
}


static void hardware_accelerometer_lis302_class_init (HardwareAccelerometerLis302Class * klass) {
	hardware_accelerometer_lis302_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (HardwareAccelerometerLis302Private));
	FSO_FRAMEWORK_ABSTRACT_OBJECT_CLASS (klass)->repr = hardware_accelerometer_lis302_real_repr;
	FSO_DEVICE_BASE_ACCELEROMETER_CLASS (klass)->start = hardware_accelerometer_lis302_real_start;
	FSO_DEVICE_BASE_ACCELEROMETER_CLASS (klass)->stop = hardware_accelerometer_lis302_real_stop;
	G_OBJECT_CLASS (klass)->constructor = hardware_accelerometer_lis302_constructor;
	G_OBJECT_CLASS (klass)->finalize = hardware_accelerometer_lis302_finalize;
}


static void hardware_accelerometer_lis302_instance_init (HardwareAccelerometerLis302 * self) {
	self->priv = HARDWARE_ACCELEROMETER_LIS302_GET_PRIVATE (self);
	self->fd = -1;
}


static void hardware_accelerometer_lis302_finalize (GObject* obj) {
	HardwareAccelerometerLis302 * self;
	self = HARDWARE_ACCELEROMETER_LIS302 (obj);
	_g_free0 (self->priv->inputnode);
	_g_free0 (self->priv->sysfsnode);
	_g_free0 (self->priv->full_scale);
	_g_io_channel_unref0 (self->priv->channel);
	self->priv->axis = (g_free (self->priv->axis), NULL);
	G_OBJECT_CLASS (hardware_accelerometer_lis302_parent_class)->finalize (obj);
}


GType hardware_accelerometer_lis302_get_type (void) {
	return hardware_accelerometer_lis302_type_id;
}


GType hardware_accelerometer_lis302_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (HardwareAccelerometerLis302Class), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) hardware_accelerometer_lis302_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (HardwareAccelerometerLis302), 0, (GInstanceInitFunc) hardware_accelerometer_lis302_instance_init, NULL };
	hardware_accelerometer_lis302_type_id = g_type_module_register_type (module, FSO_DEVICE_TYPE_BASE_ACCELEROMETER, "HardwareAccelerometerLis302", &g_define_type_info, 0);
	return hardware_accelerometer_lis302_type_id;
}


/**
 * This function gets called on plugin initialization time.
 * @return the name of your plugin here
 * @note that it needs to be a name in the format <subsystem>.<plugin>
 * else your module will be unloaded immediately.
 **/
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (subsystem != NULL, NULL);
	_tmp0_ = g_strdup (HARDWARE_PLUGIN_NAME);
	result = _tmp0_;
	return result;
}


void fso_register_function (GTypeModule* module) {
	FsoFrameworkLogger* _tmp0_;
	g_return_if_fail (module != NULL);
	hardware_accelerometer_lis302_register_type (module);
	_tmp0_ = fso_framework_theLogger;
	fso_framework_logger_debug (_tmp0_, "fsodevice.accelerometer_lis302 fso_register_function");
}



