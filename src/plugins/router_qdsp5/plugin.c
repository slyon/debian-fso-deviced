/* plugin.c generated by valac 0.14.2, the Vala compiler
 * generated from plugin.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <fsodevice.h>
#include <stdlib.h>
#include <string.h>
#include <freesmartphone.h>
#include <fsoframework.h>
#include <fsobasics.h>


#define ROUTER_TYPE_QDSP5 (router_qdsp5_get_type ())
#define ROUTER_QDSP5(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ROUTER_TYPE_QDSP5, RouterQdsp5))
#define ROUTER_QDSP5_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ROUTER_TYPE_QDSP5, RouterQdsp5Class))
#define ROUTER_IS_QDSP5(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ROUTER_TYPE_QDSP5))
#define ROUTER_IS_QDSP5_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ROUTER_TYPE_QDSP5))
#define ROUTER_QDSP5_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ROUTER_TYPE_QDSP5, RouterQdsp5Class))

typedef struct _RouterQdsp5 RouterQdsp5;
typedef struct _RouterQdsp5Class RouterQdsp5Class;
typedef struct _RouterQdsp5Private RouterQdsp5Private;
#define __g_queue_free__g_free0_0(var) ((var == NULL) ? NULL : (var = (_g_queue_free__g_free0_ (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _RouterQdsp5 {
	FsoDeviceBaseAudioRouter parent_instance;
	RouterQdsp5Private * priv;
};

struct _RouterQdsp5Class {
	FsoDeviceBaseAudioRouterClass parent_class;
};

struct _RouterQdsp5Private {
	GQueue* scenarios;
	gchar* currentscenario;
};


static gpointer router_qdsp5_parent_class = NULL;
static GType router_qdsp5_type_id = 0;

GType router_qdsp5_get_type (void) G_GNUC_CONST;
GType router_qdsp5_register_type (GTypeModule * module);
#define ROUTER_QDSP5_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ROUTER_TYPE_QDSP5, RouterQdsp5Private))
enum  {
	ROUTER_QDSP5_DUMMY_PROPERTY
};
static void _g_free0_ (gpointer var);
static void _g_queue_free__g_free0_ (GQueue* self);
#define ROUTER_QDSP5_MODULE_NAME "fsodevice.router_qdsp5"
RouterQdsp5* router_qdsp5_new (void);
RouterQdsp5* router_qdsp5_construct (GType object_type);
static void router_qdsp5_updateScenarioIfChanged (RouterQdsp5* self, const gchar* scenario);
static gboolean router_qdsp5_real_isScenarioAvailable (FsoDeviceBaseAudioRouter* base, const gchar* scenario);
static gchar** router_qdsp5_real_availableScenarios (FsoDeviceBaseAudioRouter* base, int* result_length1);
static gchar* router_qdsp5_real_currentScenario (FsoDeviceBaseAudioRouter* base);
static gchar* router_qdsp5_real_pullScenario (FsoDeviceBaseAudioRouter* base, GError** error);
static void router_qdsp5_real_pushScenario (FsoDeviceBaseAudioRouter* base, const gchar* scenario);
static void router_qdsp5_real_setScenario (FsoDeviceBaseAudioRouter* base, const gchar* scenario);
static void router_qdsp5_real_saveScenario (FsoDeviceBaseAudioRouter* base, const gchar* scenario);
static void router_qdsp5_finalize (GObject* obj);
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error);
void fso_register_function (GTypeModule* module);


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _g_queue_free__g_free0_ (GQueue* self) {
	g_queue_foreach (self, (GFunc) _g_free0_, NULL);
	g_queue_free (self);
}


RouterQdsp5* router_qdsp5_construct (GType object_type) {
	RouterQdsp5 * self = NULL;
	GQueue* _tmp0_;
	gchar* _tmp1_;
	self = (RouterQdsp5*) fso_device_base_audio_router_construct (object_type);
	_tmp0_ = g_queue_new ();
	__g_queue_free__g_free0_0 (self->priv->scenarios);
	self->priv->scenarios = _tmp0_;
	_tmp1_ = g_strdup ("unknown");
	_g_free0 (self->priv->currentscenario);
	self->priv->currentscenario = _tmp1_;
	router_qdsp5_updateScenarioIfChanged (self, "gsmhandset");
	return self;
}


RouterQdsp5* router_qdsp5_new (void) {
	return router_qdsp5_construct (ROUTER_TYPE_QDSP5);
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static void router_qdsp5_updateScenarioIfChanged (RouterQdsp5* self, const gchar* scenario) {
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (scenario != NULL);
	_tmp0_ = self->priv->currentscenario;
	_tmp1_ = scenario;
	if (g_strcmp0 (_tmp0_, _tmp1_) != 0) {
		const gchar* _tmp2_;
		const gchar* _tmp3_;
		GQuark _tmp5_ = 0U;
		static GQuark _tmp4_label0 = 0;
		const gchar* _tmp10_;
		gchar* _tmp11_;
		_tmp2_ = scenario;
		_tmp3_ = _tmp2_;
		_tmp5_ = (NULL == _tmp3_) ? 0 : g_quark_from_string (_tmp3_);
		if (_tmp5_ == ((0 != _tmp4_label0) ? _tmp4_label0 : (_tmp4_label0 = g_quark_from_static_string ("gsmhandset")))) {
			switch (0) {
				default:
				{
					do_route_audio_rpc ((guint32) 0, FALSE, FALSE);
					break;
				}
			}
		} else {
			switch (0) {
				default:
				{
					const gchar* _tmp6_;
					const gchar* _tmp7_ = NULL;
					gchar* _tmp8_ = NULL;
					gchar* _tmp9_;
					_tmp6_ = scenario;
					_tmp7_ = string_to_string (_tmp6_);
					_tmp8_ = g_strconcat ("Don't know how to handle scenario ", _tmp7_, NULL);
					_tmp9_ = _tmp8_;
					g_warning ("plugin.vala:53: %s", _tmp9_);
					_g_free0 (_tmp9_);
					break;
				}
			}
		}
		_tmp10_ = scenario;
		_tmp11_ = g_strdup (_tmp10_);
		_g_free0 (self->priv->currentscenario);
		self->priv->currentscenario = _tmp11_;
	}
}


static gboolean router_qdsp5_real_isScenarioAvailable (FsoDeviceBaseAudioRouter* base, const gchar* scenario) {
	RouterQdsp5 * self;
	gboolean result = FALSE;
	self = (RouterQdsp5*) base;
	g_return_val_if_fail (scenario != NULL, FALSE);
	result = TRUE;
	return result;
}


static gchar** router_qdsp5_real_availableScenarios (FsoDeviceBaseAudioRouter* base, int* result_length1) {
	RouterQdsp5 * self;
	gchar** result = NULL;
	gchar* _tmp0_;
	gchar** _tmp1_ = NULL;
	gchar** _tmp2_;
	gint _tmp2__length1;
	self = (RouterQdsp5*) base;
	_tmp0_ = g_strdup ("gsmhandset");
	_tmp1_ = g_new0 (gchar*, 1 + 1);
	_tmp1_[0] = _tmp0_;
	_tmp2_ = _tmp1_;
	_tmp2__length1 = 1;
	if (result_length1) {
		*result_length1 = _tmp2__length1;
	}
	result = _tmp2_;
	return result;
}


static gchar* router_qdsp5_real_currentScenario (FsoDeviceBaseAudioRouter* base) {
	RouterQdsp5 * self;
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	self = (RouterQdsp5*) base;
	_tmp0_ = self->priv->currentscenario;
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}


static gchar* router_qdsp5_real_pullScenario (FsoDeviceBaseAudioRouter* base, GError** error) {
	RouterQdsp5 * self;
	gchar* result = NULL;
	GQueue* _tmp0_;
	gpointer _tmp1_ = NULL;
	gchar* _tmp2_;
	GQueue* _tmp3_;
	gconstpointer _tmp4_ = NULL;
	gchar* _tmp5_;
	gchar* scenario;
	const gchar* _tmp6_;
	const gchar* _tmp8_;
	GError * _inner_error_ = NULL;
	self = (RouterQdsp5*) base;
	_tmp0_ = self->priv->scenarios;
	_tmp1_ = g_queue_pop_head (_tmp0_);
	_tmp2_ = (gchar*) _tmp1_;
	_g_free0 (_tmp2_);
	_tmp3_ = self->priv->scenarios;
	_tmp4_ = g_queue_peek_head (_tmp3_);
	_tmp5_ = g_strdup ((const gchar*) _tmp4_);
	scenario = _tmp5_;
	_tmp6_ = scenario;
	if (_tmp6_ == NULL) {
		GError* _tmp7_;
		_tmp7_ = g_error_new_literal (FREE_SMARTPHONE_DEVICE_AUDIO_ERROR, FREE_SMARTPHONE_DEVICE_AUDIO_ERROR_SCENARIO_STACK_UNDERFLOW, "No scenario left to activate");
		_inner_error_ = _tmp7_;
		if (_inner_error_->domain == FREE_SMARTPHONE_DEVICE_AUDIO_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (scenario);
			return NULL;
		} else {
			_g_free0 (scenario);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp8_ = scenario;
	fso_device_base_audio_router_setScenario ((FsoDeviceBaseAudioRouter*) self, _tmp8_);
	result = scenario;
	return result;
}


static void router_qdsp5_real_pushScenario (FsoDeviceBaseAudioRouter* base, const gchar* scenario) {
	RouterQdsp5 * self;
	const gchar* _tmp0_;
	GQueue* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	self = (RouterQdsp5*) base;
	g_return_if_fail (scenario != NULL);
	_tmp0_ = scenario;
	fso_device_base_audio_router_setScenario ((FsoDeviceBaseAudioRouter*) self, _tmp0_);
	_tmp1_ = self->priv->scenarios;
	_tmp2_ = scenario;
	_tmp3_ = g_strdup (_tmp2_);
	g_queue_push_head (_tmp1_, _tmp3_);
}


static void router_qdsp5_real_setScenario (FsoDeviceBaseAudioRouter* base, const gchar* scenario) {
	RouterQdsp5 * self;
	const gchar* _tmp0_;
	self = (RouterQdsp5*) base;
	g_return_if_fail (scenario != NULL);
	_tmp0_ = scenario;
	router_qdsp5_updateScenarioIfChanged (self, _tmp0_);
}


static void router_qdsp5_real_saveScenario (FsoDeviceBaseAudioRouter* base, const gchar* scenario) {
	RouterQdsp5 * self;
	self = (RouterQdsp5*) base;
	g_return_if_fail (scenario != NULL);
}


static void router_qdsp5_class_init (RouterQdsp5Class * klass) {
	router_qdsp5_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (RouterQdsp5Private));
	FSO_DEVICE_BASE_AUDIO_ROUTER_CLASS (klass)->isScenarioAvailable = router_qdsp5_real_isScenarioAvailable;
	FSO_DEVICE_BASE_AUDIO_ROUTER_CLASS (klass)->availableScenarios = router_qdsp5_real_availableScenarios;
	FSO_DEVICE_BASE_AUDIO_ROUTER_CLASS (klass)->currentScenario = router_qdsp5_real_currentScenario;
	FSO_DEVICE_BASE_AUDIO_ROUTER_CLASS (klass)->pullScenario = router_qdsp5_real_pullScenario;
	FSO_DEVICE_BASE_AUDIO_ROUTER_CLASS (klass)->pushScenario = router_qdsp5_real_pushScenario;
	FSO_DEVICE_BASE_AUDIO_ROUTER_CLASS (klass)->setScenario = router_qdsp5_real_setScenario;
	FSO_DEVICE_BASE_AUDIO_ROUTER_CLASS (klass)->saveScenario = router_qdsp5_real_saveScenario;
	G_OBJECT_CLASS (klass)->finalize = router_qdsp5_finalize;
}


static void router_qdsp5_instance_init (RouterQdsp5 * self) {
	self->priv = ROUTER_QDSP5_GET_PRIVATE (self);
}


static void router_qdsp5_finalize (GObject* obj) {
	RouterQdsp5 * self;
	self = ROUTER_QDSP5 (obj);
	__g_queue_free__g_free0_0 (self->priv->scenarios);
	_g_free0 (self->priv->currentscenario);
	G_OBJECT_CLASS (router_qdsp5_parent_class)->finalize (obj);
}


/**
 * Qdsp5 Audio Router
 **/
GType router_qdsp5_get_type (void) {
	return router_qdsp5_type_id;
}


GType router_qdsp5_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (RouterQdsp5Class), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) router_qdsp5_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RouterQdsp5), 0, (GInstanceInitFunc) router_qdsp5_instance_init, NULL };
	router_qdsp5_type_id = g_type_module_register_type (module, FSO_DEVICE_TYPE_BASE_AUDIO_ROUTER, "RouterQdsp5", &g_define_type_info, 0);
	return router_qdsp5_type_id;
}


/**
 * This function gets called on plugin initialization time.
 * @return the name of your plugin here
 * @note that it needs to be a name in the format <subsystem>.<plugin>
 * else your module will be unloaded immediately.
 **/
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (subsystem != NULL, NULL);
	_tmp0_ = g_strdup ("fsodevice.router_qdsp5");
	result = _tmp0_;
	return result;
}


void fso_register_function (GTypeModule* module) {
	FsoFrameworkLogger* _tmp0_;
	g_return_if_fail (module != NULL);
	router_qdsp5_register_type (module);
	_tmp0_ = fso_framework_theLogger;
	fso_framework_logger_debug (_tmp0_, "fsodevice.router_qdsp5 fso_register_function()");
}



