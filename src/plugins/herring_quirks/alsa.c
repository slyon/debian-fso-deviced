/* alsa.c generated by valac 0.14.2, the Vala compiler
 * generated from alsa.vala, do not modify */

/*
 * Copyright (C) 2011 Simon Busch <morphis@gravedo.de>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <fsobasics.h>
#include <alsa/asoundlib.h>
#include <stdlib.h>
#include <string.h>


#define HERRING_TYPE_ALSA_STREAM_KEEPER (herring_alsa_stream_keeper_get_type ())
#define HERRING_ALSA_STREAM_KEEPER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), HERRING_TYPE_ALSA_STREAM_KEEPER, HerringAlsaStreamKeeper))
#define HERRING_ALSA_STREAM_KEEPER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), HERRING_TYPE_ALSA_STREAM_KEEPER, HerringAlsaStreamKeeperClass))
#define HERRING_IS_ALSA_STREAM_KEEPER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), HERRING_TYPE_ALSA_STREAM_KEEPER))
#define HERRING_IS_ALSA_STREAM_KEEPER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), HERRING_TYPE_ALSA_STREAM_KEEPER))
#define HERRING_ALSA_STREAM_KEEPER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), HERRING_TYPE_ALSA_STREAM_KEEPER, HerringAlsaStreamKeeperClass))

typedef struct _HerringAlsaStreamKeeper HerringAlsaStreamKeeper;
typedef struct _HerringAlsaStreamKeeperClass HerringAlsaStreamKeeperClass;
typedef struct _HerringAlsaStreamKeeperPrivate HerringAlsaStreamKeeperPrivate;
#define _0(var) ((var == NULL) ? NULL : (var = ( (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _HerringAlsaStreamKeeper {
	FsoFrameworkAbstractObject parent_instance;
	HerringAlsaStreamKeeperPrivate * priv;
};

struct _HerringAlsaStreamKeeperClass {
	FsoFrameworkAbstractObjectClass parent_class;
};

struct _HerringAlsaStreamKeeperPrivate {
	snd_pcm_t* pcm;
	gchar* cardname;
};


static gpointer herring_alsa_stream_keeper_parent_class = NULL;
static GType herring_alsa_stream_keeper_type_id = 0;

GType herring_alsa_stream_keeper_get_type (void) G_GNUC_CONST;
GType herring_alsa_stream_keeper_register_type (GTypeModule * module);
#define HERRING_ALSA_STREAM_KEEPER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), HERRING_TYPE_ALSA_STREAM_KEEPER, HerringAlsaStreamKeeperPrivate))
enum  {
	HERRING_ALSA_STREAM_KEEPER_DUMMY_PROPERTY
};
HerringAlsaStreamKeeper* herring_alsa_stream_keeper_new (void);
HerringAlsaStreamKeeper* herring_alsa_stream_keeper_construct (GType object_type);
static gchar* herring_alsa_stream_keeper_real_repr (FsoFrameworkAbstractObject* base);
static void herring_alsa_stream_keeper_finalize (GObject* obj);


HerringAlsaStreamKeeper* herring_alsa_stream_keeper_construct (GType object_type) {
	HerringAlsaStreamKeeper * self = NULL;
	const gchar* _tmp0_;
	snd_pcm_t* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	gint rc;
	snd_pcm_t* _tmp3_;
	self = (HerringAlsaStreamKeeper*) fso_framework_abstract_object_construct (object_type);
	_tmp0_ = self->priv->cardname;
	_tmp2_ = snd_pcm_open (&_tmp1_, _tmp0_, SND_PCM_STREAM_PLAYBACK, 0);
	_0 (self->priv->pcm);
	self->priv->pcm = _tmp1_;
	rc = _tmp2_;
	_tmp3_ = self->priv->pcm;
	g_assert (_tmp3_ != NULL);
	return self;
}


HerringAlsaStreamKeeper* herring_alsa_stream_keeper_new (void) {
	return herring_alsa_stream_keeper_construct (HERRING_TYPE_ALSA_STREAM_KEEPER);
}


static gchar* herring_alsa_stream_keeper_real_repr (FsoFrameworkAbstractObject* base) {
	HerringAlsaStreamKeeper * self;
	gchar* result = NULL;
	gchar* _tmp0_;
	self = (HerringAlsaStreamKeeper*) base;
	_tmp0_ = g_strdup ("<>");
	result = _tmp0_;
	return result;
}


static void herring_alsa_stream_keeper_class_init (HerringAlsaStreamKeeperClass * klass) {
	herring_alsa_stream_keeper_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (HerringAlsaStreamKeeperPrivate));
	FSO_FRAMEWORK_ABSTRACT_OBJECT_CLASS (klass)->repr = herring_alsa_stream_keeper_real_repr;
	G_OBJECT_CLASS (klass)->finalize = herring_alsa_stream_keeper_finalize;
}


static void herring_alsa_stream_keeper_instance_init (HerringAlsaStreamKeeper * self) {
	gchar* _tmp0_;
	self->priv = HERRING_ALSA_STREAM_KEEPER_GET_PRIVATE (self);
	_tmp0_ = g_strdup ("default");
	self->priv->cardname = _tmp0_;
}


static void herring_alsa_stream_keeper_finalize (GObject* obj) {
	HerringAlsaStreamKeeper * self;
	snd_pcm_t* _tmp0_;
	self = HERRING_ALSA_STREAM_KEEPER (obj);
	_tmp0_ = self->priv->pcm;
	if (_tmp0_ != NULL) {
		snd_pcm_t* _tmp1_;
		_tmp1_ = self->priv->pcm;
		snd_pcm_close (_tmp1_);
	}
	_0 (self->priv->pcm);
	_g_free0 (self->priv->cardname);
	G_OBJECT_CLASS (herring_alsa_stream_keeper_parent_class)->finalize (obj);
}


GType herring_alsa_stream_keeper_get_type (void) {
	return herring_alsa_stream_keeper_type_id;
}


GType herring_alsa_stream_keeper_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (HerringAlsaStreamKeeperClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) herring_alsa_stream_keeper_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (HerringAlsaStreamKeeper), 0, (GInstanceInitFunc) herring_alsa_stream_keeper_instance_init, NULL };
	herring_alsa_stream_keeper_type_id = g_type_module_register_type (module, FSO_FRAMEWORK_TYPE_ABSTRACT_OBJECT, "HerringAlsaStreamKeeper", &g_define_type_info, 0);
	return herring_alsa_stream_keeper_type_id;
}



