/* resumehandler.c generated by valac 0.16.1, the Vala compiler
 * generated from resumehandler.vala, do not modify */

/*
 * Copyright (C) 2011-2012 Simon Busch <morphis@gravedo.de>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <fsobasics.h>
#include <freesmartphone.h>
#include <gio/gio.h>
#include <fsoframework.h>
#include <stdlib.h>
#include <string.h>
#include <linux/input.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <sys/types.h>


#define HERRING_TYPE_RESUME_HANDLER (herring_resume_handler_get_type ())
#define HERRING_RESUME_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), HERRING_TYPE_RESUME_HANDLER, HerringResumeHandler))
#define HERRING_RESUME_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), HERRING_TYPE_RESUME_HANDLER, HerringResumeHandlerClass))
#define HERRING_IS_RESUME_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), HERRING_TYPE_RESUME_HANDLER))
#define HERRING_IS_RESUME_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), HERRING_TYPE_RESUME_HANDLER))
#define HERRING_RESUME_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), HERRING_TYPE_RESUME_HANDLER, HerringResumeHandlerClass))

typedef struct _HerringResumeHandler HerringResumeHandler;
typedef struct _HerringResumeHandlerClass HerringResumeHandlerClass;
typedef struct _HerringResumeHandlerPrivate HerringResumeHandlerPrivate;
#define _g_io_channel_unref0(var) ((var == NULL) ? NULL : (var = (g_io_channel_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _HerringResumeHandlerRequestUsageServiceData HerringResumeHandlerRequestUsageServiceData;
typedef struct _HerringResumeHandlerWakeupSystemData HerringResumeHandlerWakeupSystemData;

struct _HerringResumeHandler {
	FsoFrameworkAbstractObject parent_instance;
	HerringResumeHandlerPrivate * priv;
};

struct _HerringResumeHandlerClass {
	FsoFrameworkAbstractObjectClass parent_class;
};

struct _HerringResumeHandlerPrivate {
	gint fd;
	GIOChannel* channel;
	FreeSmartphoneUsage* usage;
	guint readwatch;
	gint inputnodenumber;
	gint powerkeycode;
};

struct _HerringResumeHandlerRequestUsageServiceData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	HerringResumeHandler* self;
	FreeSmartphoneUsage* _tmp0_;
	FreeSmartphoneUsage* _tmp1_;
	FreeSmartphoneUsage* _tmp2_;
	FsoFrameworkLogger* _tmp3_;
	gboolean _tmp4_;
	GError* err;
	FsoFrameworkLogger* _tmp5_;
	GError* _tmp6_;
	const gchar* _tmp7_;
	const gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	GError * _inner_error_;
};

struct _HerringResumeHandlerWakeupSystemData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	HerringResumeHandler* self;
	FreeSmartphoneUsage* _tmp0_;
	GError* err;
	FsoFrameworkLogger* _tmp1_;
	GError* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	GError * _inner_error_;
};


static gpointer herring_resume_handler_parent_class = NULL;
static GType herring_resume_handler_type_id = 0;

GType herring_resume_handler_get_type (void) G_GNUC_CONST;
GType herring_resume_handler_register_type (GTypeModule * module);
#define HERRING_RESUME_HANDLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), HERRING_TYPE_RESUME_HANDLER, HerringResumeHandlerPrivate))
enum  {
	HERRING_RESUME_HANDLER_DUMMY_PROPERTY
};
static void herring_resume_handler_request_usage_service_data_free (gpointer _data);
static void herring_resume_handler_request_usage_service (HerringResumeHandler* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void herring_resume_handler_request_usage_service_finish (HerringResumeHandler* self, GAsyncResult* _res_);
static gboolean herring_resume_handler_request_usage_service_co (HerringResumeHandlerRequestUsageServiceData* _data_);
static void herring_resume_handler_request_usage_service_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void herring_resume_handler_on_system_action (HerringResumeHandler* self, FreeSmartphoneUsageSystemAction action);
static void _herring_resume_handler_on_system_action_free_smartphone_usage_system_action (FreeSmartphoneUsage* _sender, FreeSmartphoneUsageSystemAction action, gpointer self);
static void herring_resume_handler_wakeup_system_data_free (gpointer _data);
static void herring_resume_handler_wakeup_system (HerringResumeHandler* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void herring_resume_handler_wakeup_system_finish (HerringResumeHandler* self, GAsyncResult* _res_);
static gboolean herring_resume_handler_wakeup_system_co (HerringResumeHandlerWakeupSystemData* _data_);
static void herring_resume_handler_wakeup_system_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static gboolean herring_resume_handler_actionCallback (HerringResumeHandler* self, GIOChannel* source, GIOCondition condition);
static void herring_resume_handler_stop_resume_watch (HerringResumeHandler* self);
static gboolean _____lambda2_ (HerringResumeHandler* self);
static gboolean ______lambda2__gsource_func (gpointer self);
static void herring_resume_handler_setup_resume_watch (HerringResumeHandler* self);
static gboolean _herring_resume_handler_actionCallback_gio_func (GIOChannel* source, GIOCondition condition, gpointer self);
HerringResumeHandler* herring_resume_handler_new (void);
HerringResumeHandler* herring_resume_handler_construct (GType object_type);
static gboolean __lambda3_ (HerringResumeHandler* self);
static gboolean ___lambda3__gsource_func (gpointer self);
#define HERRING_MODULE_NAME "fsodevice.herring_quirks"
static gchar* herring_resume_handler_real_repr (FsoFrameworkAbstractObject* base);
static void herring_resume_handler_finalize (GObject* obj);


static void herring_resume_handler_request_usage_service_data_free (gpointer _data) {
	HerringResumeHandlerRequestUsageServiceData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (HerringResumeHandlerRequestUsageServiceData, _data_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void herring_resume_handler_request_usage_service (HerringResumeHandler* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	HerringResumeHandlerRequestUsageServiceData* _data_;
	HerringResumeHandler* _tmp0_;
	_data_ = g_slice_new0 (HerringResumeHandlerRequestUsageServiceData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, herring_resume_handler_request_usage_service);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, herring_resume_handler_request_usage_service_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	herring_resume_handler_request_usage_service_co (_data_);
}


static void herring_resume_handler_request_usage_service_finish (HerringResumeHandler* self, GAsyncResult* _res_) {
	HerringResumeHandlerRequestUsageServiceData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void herring_resume_handler_request_usage_service_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	HerringResumeHandlerRequestUsageServiceData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	herring_resume_handler_request_usage_service_co (_data_);
}


static void _herring_resume_handler_on_system_action_free_smartphone_usage_system_action (FreeSmartphoneUsage* _sender, FreeSmartphoneUsageSystemAction action, gpointer self) {
	herring_resume_handler_on_system_action (self, action);
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static gboolean herring_resume_handler_request_usage_service_co (HerringResumeHandlerRequestUsageServiceData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	{
		_data_->_state_ = 1;
		g_async_initable_new_async (FREE_SMARTPHONE_TYPE_USAGE_PROXY, 0, NULL, herring_resume_handler_request_usage_service_ready, _data_, "g-flags", 0, "g-name", FSO_FRAMEWORK_USAGE_ServiceDBusName, "g-bus-type", G_BUS_TYPE_SYSTEM, "g-object-path", FSO_FRAMEWORK_USAGE_ServicePathPrefix, "g-interface-name", "org.freesmartphone.Usage", NULL);
		return FALSE;
		_state_1:
		_data_->_tmp0_ = NULL;
		_data_->_tmp0_ = g_async_initable_new_finish (_data_->_source_object_, _data_->_res_, &_data_->_inner_error_);
		_data_->_tmp1_ = (FreeSmartphoneUsage*) _data_->_tmp0_;
		if (_data_->_inner_error_ != NULL) {
			goto __catch0_g_error;
		}
		_g_object_unref0 (_data_->self->priv->usage);
		_data_->self->priv->usage = _data_->_tmp1_;
		_data_->_tmp2_ = _data_->self->priv->usage;
		g_signal_connect_object (_data_->_tmp2_, "system-action", (GCallback) _herring_resume_handler_on_system_action_free_smartphone_usage_system_action, _data_->self, 0);
		_data_->_tmp3_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
		_data_->_tmp4_ = FALSE;
		_data_->_tmp4_ = fso_framework_logger_debug (_data_->_tmp3_, "Finished with setup up FSO usage subsystem for use!");
		g_assert (_data_->_tmp4_);
	}
	goto __finally0;
	__catch0_g_error:
	{
		_data_->err = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp5_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
		_data_->_tmp6_ = _data_->err;
		_data_->_tmp7_ = _data_->_tmp6_->message;
		_data_->_tmp8_ = NULL;
		_data_->_tmp8_ = string_to_string (_data_->_tmp7_);
		_data_->_tmp9_ = NULL;
		_data_->_tmp9_ = g_strconcat ("Could not request proxy object for usage service: ", _data_->_tmp8_, NULL);
		_data_->_tmp10_ = _data_->_tmp9_;
		fso_framework_logger_error (_data_->_tmp5_, _data_->_tmp10_);
		_g_free0 (_data_->_tmp10_);
		_g_error_free0 (_data_->err);
	}
	__finally0:
	if (_data_->_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void herring_resume_handler_wakeup_system_data_free (gpointer _data) {
	HerringResumeHandlerWakeupSystemData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (HerringResumeHandlerWakeupSystemData, _data_);
}


static void herring_resume_handler_wakeup_system (HerringResumeHandler* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	HerringResumeHandlerWakeupSystemData* _data_;
	HerringResumeHandler* _tmp0_;
	_data_ = g_slice_new0 (HerringResumeHandlerWakeupSystemData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, herring_resume_handler_wakeup_system);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, herring_resume_handler_wakeup_system_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	herring_resume_handler_wakeup_system_co (_data_);
}


static void herring_resume_handler_wakeup_system_finish (HerringResumeHandler* self, GAsyncResult* _res_) {
	HerringResumeHandlerWakeupSystemData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void herring_resume_handler_wakeup_system_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	HerringResumeHandlerWakeupSystemData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	herring_resume_handler_wakeup_system_co (_data_);
}


static gboolean herring_resume_handler_wakeup_system_co (HerringResumeHandlerWakeupSystemData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	{
		_data_->_tmp0_ = _data_->self->priv->usage;
		_data_->_state_ = 1;
		free_smartphone_usage_resume (_data_->_tmp0_, "", "", herring_resume_handler_wakeup_system_ready, _data_);
		return FALSE;
		_state_1:
		free_smartphone_usage_resume_finish (_data_->_tmp0_, _data_->_res_, &_data_->_inner_error_);
		if (_data_->_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
	}
	goto __finally1;
	__catch1_g_error:
	{
		_data_->err = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp1_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
		_data_->_tmp2_ = _data_->err;
		_data_->_tmp3_ = _data_->_tmp2_->message;
		_data_->_tmp4_ = NULL;
		_data_->_tmp4_ = string_to_string (_data_->_tmp3_);
		_data_->_tmp5_ = NULL;
		_data_->_tmp5_ = g_strconcat ("Could not tell the usage daemon to wakeup the system completely: ", _data_->_tmp4_, NULL);
		_data_->_tmp6_ = _data_->_tmp5_;
		fso_framework_logger_error (_data_->_tmp1_, _data_->_tmp6_);
		_g_free0 (_data_->_tmp6_);
		_g_error_free0 (_data_->err);
	}
	__finally1:
	if (_data_->_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static gboolean _____lambda2_ (HerringResumeHandler* self) {
	gboolean result = FALSE;
	herring_resume_handler_wakeup_system (self, NULL, NULL);
	result = FALSE;
	return result;
}


static gboolean ______lambda2__gsource_func (gpointer self) {
	gboolean result;
	result = _____lambda2_ (self);
	return result;
}


static gboolean herring_resume_handler_actionCallback (HerringResumeHandler* self, GIOChannel* source, GIOCondition condition) {
	gboolean result = FALSE;
	struct input_event _tmp0_ = {0};
	struct input_event ev;
	GIOCondition _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	ev = _tmp0_;
	_tmp1_ = condition;
	if ((_tmp1_ & G_IO_IN) == G_IO_IN) {
		gint _tmp2_;
		gssize _tmp3_ = 0L;
		gssize bytesread;
		gssize _tmp4_;
		_tmp2_ = self->priv->fd;
		_tmp3_ = read (_tmp2_, &ev, (gsize) sizeof (struct input_event));
		bytesread = _tmp3_;
		_tmp4_ = bytesread;
		if (_tmp4_ == ((gssize) 0)) {
			FsoFrameworkLogger* _tmp5_;
			gint _tmp6_;
			gchar* _tmp7_ = NULL;
			gchar* _tmp8_;
			gchar* _tmp9_ = NULL;
			gchar* _tmp10_;
			gboolean _tmp11_ = FALSE;
			_tmp5_ = ((FsoFrameworkAbstractObject*) self)->logger;
			_tmp6_ = self->priv->fd;
			_tmp7_ = g_strdup_printf ("%i", _tmp6_);
			_tmp8_ = _tmp7_;
			_tmp9_ = g_strconcat ("Action on input node, but can't read from fd ", _tmp8_, "; waking up!", NULL);
			_tmp10_ = _tmp9_;
			_tmp11_ = fso_framework_logger_debug (_tmp5_, _tmp10_);
			g_assert (_tmp11_);
			_g_free0 (_tmp10_);
			_g_free0 (_tmp8_);
		} else {
			struct input_event _tmp12_;
			guint16 _tmp13_;
			gint _tmp14_;
			_tmp12_ = ev;
			_tmp13_ = _tmp12_.code;
			_tmp14_ = self->priv->powerkeycode;
			if (((gint) _tmp13_) == _tmp14_) {
				FsoFrameworkLogger* _tmp15_;
				gboolean _tmp16_ = FALSE;
				_tmp15_ = ((FsoFrameworkAbstractObject*) self)->logger;
				_tmp16_ = fso_framework_logger_debug (_tmp15_, "Power key; waking up!");
				g_assert (_tmp16_);
				herring_resume_handler_stop_resume_watch (self);
				g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ______lambda2__gsource_func, g_object_ref (self), g_object_unref);
			} else {
				FsoFrameworkLogger* _tmp17_;
				struct input_event _tmp18_;
				guint16 _tmp19_;
				gchar* _tmp20_ = NULL;
				gchar* _tmp21_;
				gchar* _tmp22_ = NULL;
				gchar* _tmp23_;
				gboolean _tmp24_ = FALSE;
				_tmp17_ = ((FsoFrameworkAbstractObject*) self)->logger;
				_tmp18_ = ev;
				_tmp19_ = _tmp18_.code;
				_tmp20_ = g_strdup_printf ("%hu", _tmp19_);
				_tmp21_ = _tmp20_;
				_tmp22_ = g_strconcat ("Some other key w/ value ", _tmp21_, "; NOT waking up!", NULL);
				_tmp23_ = _tmp22_;
				_tmp24_ = fso_framework_logger_debug (_tmp17_, _tmp23_);
				g_assert (_tmp24_);
				_g_free0 (_tmp23_);
				_g_free0 (_tmp21_);
			}
		}
	}
	result = TRUE;
	return result;
}


static void herring_resume_handler_stop_resume_watch (HerringResumeHandler* self) {
	guint _tmp0_;
	FsoFrameworkLogger* _tmp1_;
	gboolean _tmp2_ = FALSE;
	gint _tmp3_;
	gint _tmp4_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->readwatch;
	g_source_remove (_tmp0_);
	_tmp1_ = ((FsoFrameworkAbstractObject*) self)->logger;
	_tmp2_ = fso_framework_logger_debug (_tmp1_, "Ungrabbing input node");
	g_assert (_tmp2_);
	_tmp3_ = self->priv->fd;
	ioctl (_tmp3_, EVIOCGRAB, 0);
	_tmp4_ = self->priv->fd;
	close (_tmp4_);
}


static gboolean _herring_resume_handler_actionCallback_gio_func (GIOChannel* source, GIOCondition condition, gpointer self) {
	gboolean result;
	result = herring_resume_handler_actionCallback (self, source, condition);
	return result;
}


static void herring_resume_handler_setup_resume_watch (HerringResumeHandler* self) {
	gint _tmp0_;
	FsoFrameworkLogger* _tmp3_;
	gboolean _tmp4_ = FALSE;
	gint _tmp5_;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_;
	gint _tmp10_ = 0;
	gint _tmp11_;
	gint _tmp12_;
	GIOChannel* _tmp13_;
	GIOChannel* _tmp21_;
	GIOChannel* _tmp22_;
	guint _tmp23_ = 0U;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->fd;
	if (_tmp0_ != 0) {
		FsoFrameworkLogger* _tmp1_;
		gint _tmp2_;
		_tmp1_ = ((FsoFrameworkAbstractObject*) self)->logger;
		fso_framework_logger_warning (_tmp1_, "Input node was still open; closing it first ...");
		_tmp2_ = self->priv->fd;
		close (_tmp2_);
	}
	_tmp3_ = ((FsoFrameworkAbstractObject*) self)->logger;
	_tmp4_ = fso_framework_logger_debug (_tmp3_, "Grabbing input node");
	g_assert (_tmp4_);
	_tmp5_ = self->priv->inputnodenumber;
	_tmp6_ = g_strdup_printf ("%i", _tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = g_strconcat ("/dev/input/event", _tmp7_, NULL);
	_tmp9_ = _tmp8_;
	_tmp10_ = open (_tmp9_, O_RDONLY, (mode_t) 0);
	self->priv->fd = _tmp10_;
	_g_free0 (_tmp9_);
	_g_free0 (_tmp7_);
	_tmp11_ = self->priv->fd;
	ioctl (_tmp11_, EVIOCGRAB, 1);
	_tmp12_ = self->priv->fd;
	_tmp13_ = g_io_channel_unix_new (_tmp12_);
	_g_io_channel_unref0 (self->priv->channel);
	self->priv->channel = _tmp13_;
	{
		GIOChannel* _tmp14_;
		_tmp14_ = self->priv->channel;
		g_io_channel_set_encoding (_tmp14_, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_IO_CHANNEL_ERROR) {
				goto __catch2_g_io_channel_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	goto __finally2;
	__catch2_g_io_channel_error:
	{
		GError* e = NULL;
		FsoFrameworkLogger* _tmp15_;
		GError* _tmp16_;
		const gchar* _tmp17_;
		const gchar* _tmp18_ = NULL;
		gchar* _tmp19_ = NULL;
		gchar* _tmp20_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp15_ = ((FsoFrameworkAbstractObject*) self)->logger;
		_tmp16_ = e;
		_tmp17_ = _tmp16_->message;
		_tmp18_ = string_to_string (_tmp17_);
		_tmp19_ = g_strconcat ("Can't set channel encoding to null: ", _tmp18_, NULL);
		_tmp20_ = _tmp19_;
		fso_framework_logger_warning (_tmp15_, _tmp20_);
		_g_free0 (_tmp20_);
		_g_error_free0 (e);
	}
	__finally2:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp21_ = self->priv->channel;
	g_io_channel_set_buffer_size (_tmp21_, (gsize) 32768);
	_tmp22_ = self->priv->channel;
	_tmp23_ = g_io_add_watch_full (_tmp22_, 0, G_IO_IN | G_IO_HUP, _herring_resume_handler_actionCallback_gio_func, g_object_ref (self), g_object_unref);
	self->priv->readwatch = _tmp23_;
}


static void herring_resume_handler_on_system_action (HerringResumeHandler* self, FreeSmartphoneUsageSystemAction action) {
	FreeSmartphoneUsageSystemAction _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = action;
	switch (_tmp0_) {
		case FREE_SMARTPHONE_USAGE_SYSTEM_ACTION_RESUME:
		case FREE_SMARTPHONE_USAGE_SYSTEM_ACTION_ALIVE:
		{
			FsoFrameworkLogger* _tmp1_;
			gboolean _tmp2_ = FALSE;
			_tmp1_ = ((FsoFrameworkAbstractObject*) self)->logger;
			_tmp2_ = fso_framework_logger_debug (_tmp1_, "System is alive again; stopping resume watch ...");
			g_assert (_tmp2_);
			herring_resume_handler_stop_resume_watch (self);
			break;
		}
		case FREE_SMARTPHONE_USAGE_SYSTEM_ACTION_SUSPEND:
		{
			FsoFrameworkLogger* _tmp3_;
			gboolean _tmp4_ = FALSE;
			_tmp3_ = ((FsoFrameworkAbstractObject*) self)->logger;
			_tmp4_ = fso_framework_logger_debug (_tmp3_, "System is in suspend state now; starting resume watch ...");
			g_assert (_tmp4_);
			herring_resume_handler_setup_resume_watch (self);
			break;
		}
		default:
		break;
	}
}


static gboolean __lambda3_ (HerringResumeHandler* self) {
	gboolean result = FALSE;
	herring_resume_handler_request_usage_service (self, NULL, NULL);
	result = FALSE;
	return result;
}


static gboolean ___lambda3__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda3_ (self);
	return result;
}


HerringResumeHandler* herring_resume_handler_construct (GType object_type) {
	HerringResumeHandler * self = NULL;
	FsoFrameworkSmartKeyFile* _tmp0_;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gint _tmp4_ = 0;
	FsoFrameworkSmartKeyFile* _tmp5_;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_;
	gint _tmp9_ = 0;
	self = (HerringResumeHandler*) fso_framework_abstract_object_construct (object_type);
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ___lambda3__gsource_func, g_object_ref (self), g_object_unref);
	_tmp0_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp1_ = string_to_string (HERRING_MODULE_NAME);
	_tmp2_ = g_strconcat (_tmp1_, "/resume_handler", NULL);
	_tmp3_ = _tmp2_;
	_tmp4_ = fso_framework_smart_key_file_intValue (_tmp0_, _tmp3_, "wakeup_inputnode", -1);
	self->priv->inputnodenumber = _tmp4_;
	_g_free0 (_tmp3_);
	_tmp5_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp6_ = string_to_string (HERRING_MODULE_NAME);
	_tmp7_ = g_strconcat (_tmp6_, "/resume_handler", NULL);
	_tmp8_ = _tmp7_;
	_tmp9_ = fso_framework_smart_key_file_intValue (_tmp5_, _tmp8_, "wakeup_powerkeycode", -1);
	self->priv->powerkeycode = _tmp9_;
	_g_free0 (_tmp8_);
	return self;
}


HerringResumeHandler* herring_resume_handler_new (void) {
	return herring_resume_handler_construct (HERRING_TYPE_RESUME_HANDLER);
}


static gchar* herring_resume_handler_real_repr (FsoFrameworkAbstractObject* base) {
	HerringResumeHandler * self;
	gchar* result = NULL;
	gchar* _tmp0_;
	self = (HerringResumeHandler*) base;
	_tmp0_ = g_strdup ("<>");
	result = _tmp0_;
	return result;
}


static void herring_resume_handler_class_init (HerringResumeHandlerClass * klass) {
	herring_resume_handler_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (HerringResumeHandlerPrivate));
	FSO_FRAMEWORK_ABSTRACT_OBJECT_CLASS (klass)->repr = herring_resume_handler_real_repr;
	G_OBJECT_CLASS (klass)->finalize = herring_resume_handler_finalize;
}


static void herring_resume_handler_instance_init (HerringResumeHandler * self) {
	self->priv = HERRING_RESUME_HANDLER_GET_PRIVATE (self);
	self->priv->fd = 0;
}


static void herring_resume_handler_finalize (GObject* obj) {
	HerringResumeHandler * self;
	self = HERRING_RESUME_HANDLER (obj);
	_g_io_channel_unref0 (self->priv->channel);
	_g_object_unref0 (self->priv->usage);
	G_OBJECT_CLASS (herring_resume_handler_parent_class)->finalize (obj);
}


GType herring_resume_handler_get_type (void) {
	return herring_resume_handler_type_id;
}


GType herring_resume_handler_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (HerringResumeHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) herring_resume_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (HerringResumeHandler), 0, (GInstanceInitFunc) herring_resume_handler_instance_init, NULL };
	herring_resume_handler_type_id = g_type_module_register_type (module, FSO_FRAMEWORK_TYPE_ABSTRACT_OBJECT, "HerringResumeHandler", &g_define_type_info, 0);
	return herring_resume_handler_type_id;
}



