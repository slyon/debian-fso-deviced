/* plugin.c generated by valac 0.16.1, the Vala compiler
 * generated from plugin.vala, do not modify */

/*
 * Copyright (C) 2009-2012 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <fsodevice.h>
#include <fsoframework.h>
#include <freesmartphone.h>
#include <fsobasics.h>


#define OPENMOKO_TYPE_DEVICE_POWER_CONTROL (openmoko_device_power_control_get_type ())
#define OPENMOKO_DEVICE_POWER_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OPENMOKO_TYPE_DEVICE_POWER_CONTROL, OpenmokoDevicePowerControl))
#define OPENMOKO_DEVICE_POWER_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OPENMOKO_TYPE_DEVICE_POWER_CONTROL, OpenmokoDevicePowerControlClass))
#define OPENMOKO_IS_DEVICE_POWER_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OPENMOKO_TYPE_DEVICE_POWER_CONTROL))
#define OPENMOKO_IS_DEVICE_POWER_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OPENMOKO_TYPE_DEVICE_POWER_CONTROL))
#define OPENMOKO_DEVICE_POWER_CONTROL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OPENMOKO_TYPE_DEVICE_POWER_CONTROL, OpenmokoDevicePowerControlClass))

typedef struct _OpenmokoDevicePowerControl OpenmokoDevicePowerControl;
typedef struct _OpenmokoDevicePowerControlClass OpenmokoDevicePowerControlClass;
typedef struct _OpenmokoDevicePowerControlPrivate OpenmokoDevicePowerControlPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define OPENMOKO_TYPE_USB_HOST_MODE_CONTROL (openmoko_usb_host_mode_control_get_type ())
#define OPENMOKO_USB_HOST_MODE_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OPENMOKO_TYPE_USB_HOST_MODE_CONTROL, OpenmokoUsbHostModeControl))
#define OPENMOKO_USB_HOST_MODE_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OPENMOKO_TYPE_USB_HOST_MODE_CONTROL, OpenmokoUsbHostModeControlClass))
#define OPENMOKO_IS_USB_HOST_MODE_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OPENMOKO_TYPE_USB_HOST_MODE_CONTROL))
#define OPENMOKO_IS_USB_HOST_MODE_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OPENMOKO_TYPE_USB_HOST_MODE_CONTROL))
#define OPENMOKO_USB_HOST_MODE_CONTROL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OPENMOKO_TYPE_USB_HOST_MODE_CONTROL, OpenmokoUsbHostModeControlClass))

typedef struct _OpenmokoUsbHostModeControl OpenmokoUsbHostModeControl;
typedef struct _OpenmokoUsbHostModeControlClass OpenmokoUsbHostModeControlClass;
typedef struct _OpenmokoUsbHostModeControlPrivate OpenmokoUsbHostModeControlPrivate;

#define OPENMOKO_TYPE_WI_FI_POWER_CONTROL (openmoko_wi_fi_power_control_get_type ())
#define OPENMOKO_WI_FI_POWER_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OPENMOKO_TYPE_WI_FI_POWER_CONTROL, OpenmokoWiFiPowerControl))
#define OPENMOKO_WI_FI_POWER_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OPENMOKO_TYPE_WI_FI_POWER_CONTROL, OpenmokoWiFiPowerControlClass))
#define OPENMOKO_IS_WI_FI_POWER_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OPENMOKO_TYPE_WI_FI_POWER_CONTROL))
#define OPENMOKO_IS_WI_FI_POWER_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OPENMOKO_TYPE_WI_FI_POWER_CONTROL))
#define OPENMOKO_WI_FI_POWER_CONTROL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OPENMOKO_TYPE_WI_FI_POWER_CONTROL, OpenmokoWiFiPowerControlClass))

typedef struct _OpenmokoWiFiPowerControl OpenmokoWiFiPowerControl;
typedef struct _OpenmokoWiFiPowerControlClass OpenmokoWiFiPowerControlClass;
typedef struct _OpenmokoWiFiPowerControlPrivate OpenmokoWiFiPowerControlPrivate;

struct _OpenmokoDevicePowerControl {
	FsoDeviceBasePowerControl parent_instance;
	OpenmokoDevicePowerControlPrivate * priv;
};

struct _OpenmokoDevicePowerControlClass {
	FsoDeviceBasePowerControlClass parent_class;
};

struct _OpenmokoDevicePowerControlPrivate {
	FsoFrameworkSubsystem* subsystem;
	gchar* sysfsnode;
	gchar* name;
};

struct _OpenmokoUsbHostModeControl {
	FsoDeviceBasePowerControl parent_instance;
	OpenmokoUsbHostModeControlPrivate * priv;
};

struct _OpenmokoUsbHostModeControlClass {
	FsoDeviceBasePowerControlClass parent_class;
};

struct _OpenmokoUsbHostModeControlPrivate {
	FsoFrameworkSubsystem* subsystem;
	gchar* sysfsnode;
	gchar* umodenode;
	gchar* name;
};

struct _OpenmokoWiFiPowerControl {
	FsoDeviceBasePowerControl parent_instance;
	OpenmokoWiFiPowerControlPrivate * priv;
};

struct _OpenmokoWiFiPowerControlClass {
	FsoDeviceBasePowerControlClass parent_class;
};

struct _OpenmokoWiFiPowerControlPrivate {
	FsoFrameworkSubsystem* subsystem;
	gchar* sysfsnode;
	gchar* name;
};


static gpointer openmoko_device_power_control_parent_class = NULL;
static GType openmoko_device_power_control_type_id = 0;
static gpointer openmoko_usb_host_mode_control_parent_class = NULL;
extern gchar* sysfs_root;
static GType openmoko_usb_host_mode_control_type_id = 0;
static gpointer openmoko_wi_fi_power_control_parent_class = NULL;
static GType openmoko_wi_fi_power_control_type_id = 0;
extern GList* resources;
GList* resources = NULL;
extern GList* instances;
GList* instances = NULL;
gchar* sysfs_root = NULL;

#define OPENMOKO_CONFIG_SECTION "fsodevice.openmoko_powercontrol"
GType openmoko_device_power_control_get_type (void) G_GNUC_CONST;
GType openmoko_device_power_control_register_type (GTypeModule * module);
#define OPENMOKO_DEVICE_POWER_CONTROL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), OPENMOKO_TYPE_DEVICE_POWER_CONTROL, OpenmokoDevicePowerControlPrivate))
enum  {
	OPENMOKO_DEVICE_POWER_CONTROL_DUMMY_PROPERTY
};
OpenmokoDevicePowerControl* openmoko_device_power_control_new (FsoFrameworkSubsystem* subsystem, const gchar* sysfsnode);
OpenmokoDevicePowerControl* openmoko_device_power_control_construct (GType object_type, FsoFrameworkSubsystem* subsystem, const gchar* sysfsnode);
static void openmoko_device_power_control_finalize (GObject* obj);
GType openmoko_usb_host_mode_control_get_type (void) G_GNUC_CONST;
GType openmoko_usb_host_mode_control_register_type (GTypeModule * module);
#define OPENMOKO_USB_HOST_MODE_CONTROL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), OPENMOKO_TYPE_USB_HOST_MODE_CONTROL, OpenmokoUsbHostModeControlPrivate))
enum  {
	OPENMOKO_USB_HOST_MODE_CONTROL_DUMMY_PROPERTY
};
OpenmokoUsbHostModeControl* openmoko_usb_host_mode_control_new (FsoFrameworkSubsystem* subsystem, const gchar* sysfsnode);
OpenmokoUsbHostModeControl* openmoko_usb_host_mode_control_construct (GType object_type, FsoFrameworkSubsystem* subsystem, const gchar* sysfsnode);
static void openmoko_usb_host_mode_control_real_setPower (FsoDeviceBasePowerControl* base, gboolean on);
static void openmoko_usb_host_mode_control_finalize (GObject* obj);
GType openmoko_wi_fi_power_control_get_type (void) G_GNUC_CONST;
GType openmoko_wi_fi_power_control_register_type (GTypeModule * module);
#define OPENMOKO_WI_FI_POWER_CONTROL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), OPENMOKO_TYPE_WI_FI_POWER_CONTROL, OpenmokoWiFiPowerControlPrivate))
enum  {
	OPENMOKO_WI_FI_POWER_CONTROL_DUMMY_PROPERTY
};
OpenmokoWiFiPowerControl* openmoko_wi_fi_power_control_new (FsoFrameworkSubsystem* subsystem, const gchar* sysfsnode);
OpenmokoWiFiPowerControl* openmoko_wi_fi_power_control_construct (GType object_type, FsoFrameworkSubsystem* subsystem, const gchar* sysfsnode);
static gboolean openmoko_wi_fi_power_control_real_getPower (FsoDeviceBasePowerControl* base);
static void openmoko_wi_fi_power_control_real_setPower (FsoDeviceBasePowerControl* base, gboolean on);
static void openmoko_wi_fi_power_control_finalize (GObject* obj);
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error);
void fso_register_function (GTypeModule* module);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


OpenmokoDevicePowerControl* openmoko_device_power_control_construct (GType object_type, FsoFrameworkSubsystem* subsystem, const gchar* sysfsnode) {
	OpenmokoDevicePowerControl * self = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	FsoFrameworkSubsystem* _tmp3_;
	FsoFrameworkSubsystem* _tmp4_;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	const gchar* _tmp7_;
	gchar* _tmp8_ = NULL;
	FsoFrameworkSubsystem* _tmp9_;
	FsoFrameworkLogger* _tmp10_;
	g_return_val_if_fail (subsystem != NULL, NULL);
	g_return_val_if_fail (sysfsnode != NULL, NULL);
	_tmp0_ = sysfsnode;
	_tmp1_ = g_build_filename (_tmp0_, "power_on", NULL);
	_tmp2_ = _tmp1_;
	self = (OpenmokoDevicePowerControl*) fso_device_base_power_control_construct (object_type, _tmp2_, "1", "0", (guint) 3);
	_g_free0 (_tmp2_);
	_tmp3_ = subsystem;
	_tmp4_ = _g_object_ref0 (_tmp3_);
	_g_object_unref0 (self->priv->subsystem);
	self->priv->subsystem = _tmp4_;
	_tmp5_ = sysfsnode;
	_tmp6_ = g_strdup (_tmp5_);
	_g_free0 (self->priv->sysfsnode);
	self->priv->sysfsnode = _tmp6_;
	_tmp7_ = sysfsnode;
	_tmp8_ = g_path_get_basename (_tmp7_);
	_g_free0 (self->priv->name);
	self->priv->name = _tmp8_;
	_tmp9_ = subsystem;
	fso_framework_subsystem_registerObjectForServiceWithPrefix (_tmp9_, FREE_SMARTPHONE_DEVICE_TYPE_POWER_CONTROL, (GBoxedCopyFunc) g_object_ref, g_object_unref, FSO_FRAMEWORK_DEVICE_ServiceDBusName, FSO_FRAMEWORK_DEVICE_PowerControlServicePath, (FreeSmartphoneDevicePowerControl*) self);
	_tmp10_ = ((FsoFrameworkAbstractObject*) self)->logger;
	fso_framework_logger_info (_tmp10_, "created.");
	return self;
}


OpenmokoDevicePowerControl* openmoko_device_power_control_new (FsoFrameworkSubsystem* subsystem, const gchar* sysfsnode) {
	return openmoko_device_power_control_construct (OPENMOKO_TYPE_DEVICE_POWER_CONTROL, subsystem, sysfsnode);
}


static void openmoko_device_power_control_class_init (OpenmokoDevicePowerControlClass * klass) {
	openmoko_device_power_control_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (OpenmokoDevicePowerControlPrivate));
	G_OBJECT_CLASS (klass)->finalize = openmoko_device_power_control_finalize;
}


static void openmoko_device_power_control_instance_init (OpenmokoDevicePowerControl * self) {
	self->priv = OPENMOKO_DEVICE_POWER_CONTROL_GET_PRIVATE (self);
}


static void openmoko_device_power_control_finalize (GObject* obj) {
	OpenmokoDevicePowerControl * self;
	self = OPENMOKO_DEVICE_POWER_CONTROL (obj);
	_g_object_unref0 (self->priv->subsystem);
	_g_free0 (self->priv->sysfsnode);
	_g_free0 (self->priv->name);
	G_OBJECT_CLASS (openmoko_device_power_control_parent_class)->finalize (obj);
}


/**
 * Common device power control for Openmoko GTA01 and Openmoko GTA02
 **/
GType openmoko_device_power_control_get_type (void) {
	return openmoko_device_power_control_type_id;
}


GType openmoko_device_power_control_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (OpenmokoDevicePowerControlClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) openmoko_device_power_control_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (OpenmokoDevicePowerControl), 0, (GInstanceInitFunc) openmoko_device_power_control_instance_init, NULL };
	openmoko_device_power_control_type_id = g_type_module_register_type (module, FSO_DEVICE_TYPE_BASE_POWER_CONTROL, "OpenmokoDevicePowerControl", &g_define_type_info, 0);
	return openmoko_device_power_control_type_id;
}


OpenmokoUsbHostModeControl* openmoko_usb_host_mode_control_construct (GType object_type, FsoFrameworkSubsystem* subsystem, const gchar* sysfsnode) {
	OpenmokoUsbHostModeControl * self = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	FsoFrameworkSubsystem* _tmp3_;
	FsoFrameworkSubsystem* _tmp4_;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	const gchar* _tmp7_;
	gchar* _tmp8_ = NULL;
	const gchar* _tmp9_;
	gchar* _tmp10_ = NULL;
	FsoFrameworkSubsystem* _tmp11_;
	FsoFrameworkLogger* _tmp12_;
	g_return_val_if_fail (subsystem != NULL, NULL);
	g_return_val_if_fail (sysfsnode != NULL, NULL);
	_tmp0_ = sysfsnode;
	_tmp1_ = g_build_filename (_tmp0_, "power_on", NULL);
	_tmp2_ = _tmp1_;
	self = (OpenmokoUsbHostModeControl*) fso_device_base_power_control_construct (object_type, _tmp2_, "1", "0", (guint) 3);
	_g_free0 (_tmp2_);
	_tmp3_ = subsystem;
	_tmp4_ = _g_object_ref0 (_tmp3_);
	_g_object_unref0 (self->priv->subsystem);
	self->priv->subsystem = _tmp4_;
	_tmp5_ = sysfsnode;
	_tmp6_ = g_strdup (_tmp5_);
	_g_free0 (self->priv->sysfsnode);
	self->priv->sysfsnode = _tmp6_;
	_tmp7_ = sysfs_root;
	_tmp8_ = g_build_filename (_tmp7_, "devices", "platform", "s3c2410-ohci", "usb_mode", NULL);
	_g_free0 (self->priv->umodenode);
	self->priv->umodenode = _tmp8_;
	_tmp9_ = sysfsnode;
	_tmp10_ = g_path_get_basename (_tmp9_);
	_g_free0 (self->priv->name);
	self->priv->name = _tmp10_;
	_tmp11_ = subsystem;
	fso_framework_subsystem_registerObjectForServiceWithPrefix (_tmp11_, FREE_SMARTPHONE_DEVICE_TYPE_POWER_CONTROL, (GBoxedCopyFunc) g_object_ref, g_object_unref, FSO_FRAMEWORK_DEVICE_ServiceDBusName, FSO_FRAMEWORK_DEVICE_PowerControlServicePath, (FreeSmartphoneDevicePowerControl*) self);
	_tmp12_ = ((FsoFrameworkAbstractObject*) self)->logger;
	fso_framework_logger_info (_tmp12_, "created.");
	return self;
}


OpenmokoUsbHostModeControl* openmoko_usb_host_mode_control_new (FsoFrameworkSubsystem* subsystem, const gchar* sysfsnode) {
	return openmoko_usb_host_mode_control_construct (OPENMOKO_TYPE_USB_HOST_MODE_CONTROL, subsystem, sysfsnode);
}


static void openmoko_usb_host_mode_control_real_setPower (FsoDeviceBasePowerControl* base, gboolean on) {
	OpenmokoUsbHostModeControl * self;
	gboolean _tmp0_;
	const gchar* _tmp1_ = NULL;
	gboolean _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* logical;
	const gchar* _tmp5_;
	self = (OpenmokoUsbHostModeControl*) base;
	_tmp0_ = on;
	FSO_DEVICE_BASE_POWER_CONTROL_CLASS (openmoko_usb_host_mode_control_parent_class)->setPower (FSO_DEVICE_BASE_POWER_CONTROL (self), _tmp0_);
	_tmp2_ = on;
	if (_tmp2_) {
		_tmp1_ = "host";
	} else {
		_tmp1_ = "device";
	}
	_tmp3_ = _tmp1_;
	_tmp4_ = g_strdup (_tmp3_);
	logical = _tmp4_;
	_tmp5_ = self->priv->umodenode;
	fso_framework_file_handling_write (logical, _tmp5_, FALSE);
	_g_free0 (logical);
}


static void openmoko_usb_host_mode_control_class_init (OpenmokoUsbHostModeControlClass * klass) {
	openmoko_usb_host_mode_control_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (OpenmokoUsbHostModeControlPrivate));
	FSO_DEVICE_BASE_POWER_CONTROL_CLASS (klass)->setPower = openmoko_usb_host_mode_control_real_setPower;
	G_OBJECT_CLASS (klass)->finalize = openmoko_usb_host_mode_control_finalize;
}


static void openmoko_usb_host_mode_control_instance_init (OpenmokoUsbHostModeControl * self) {
	self->priv = OPENMOKO_USB_HOST_MODE_CONTROL_GET_PRIVATE (self);
}


static void openmoko_usb_host_mode_control_finalize (GObject* obj) {
	OpenmokoUsbHostModeControl * self;
	self = OPENMOKO_USB_HOST_MODE_CONTROL (obj);
	_g_object_unref0 (self->priv->subsystem);
	_g_free0 (self->priv->sysfsnode);
	_g_free0 (self->priv->umodenode);
	_g_free0 (self->priv->name);
	G_OBJECT_CLASS (openmoko_usb_host_mode_control_parent_class)->finalize (obj);
}


/**
 * UsbHost mode control for Openmoko GTA02
 **/
GType openmoko_usb_host_mode_control_get_type (void) {
	return openmoko_usb_host_mode_control_type_id;
}


GType openmoko_usb_host_mode_control_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (OpenmokoUsbHostModeControlClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) openmoko_usb_host_mode_control_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (OpenmokoUsbHostModeControl), 0, (GInstanceInitFunc) openmoko_usb_host_mode_control_instance_init, NULL };
	openmoko_usb_host_mode_control_type_id = g_type_module_register_type (module, FSO_DEVICE_TYPE_BASE_POWER_CONTROL, "OpenmokoUsbHostModeControl", &g_define_type_info, 0);
	return openmoko_usb_host_mode_control_type_id;
}


OpenmokoWiFiPowerControl* openmoko_wi_fi_power_control_construct (GType object_type, FsoFrameworkSubsystem* subsystem, const gchar* sysfsnode) {
	OpenmokoWiFiPowerControl * self = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	FsoFrameworkSubsystem* _tmp3_;
	FsoFrameworkSubsystem* _tmp4_;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	const gchar* _tmp7_;
	gchar* _tmp8_ = NULL;
	FsoFrameworkSubsystem* _tmp9_;
	FsoFrameworkLogger* _tmp10_;
	g_return_val_if_fail (subsystem != NULL, NULL);
	g_return_val_if_fail (sysfsnode != NULL, NULL);
	_tmp0_ = sysfsnode;
	_tmp1_ = g_build_filename (_tmp0_, NULL, NULL);
	_tmp2_ = _tmp1_;
	self = (OpenmokoWiFiPowerControl*) fso_device_base_power_control_construct (object_type, _tmp2_, "1", "0", (guint) 3);
	_g_free0 (_tmp2_);
	_tmp3_ = subsystem;
	_tmp4_ = _g_object_ref0 (_tmp3_);
	_g_object_unref0 (self->priv->subsystem);
	self->priv->subsystem = _tmp4_;
	_tmp5_ = sysfsnode;
	_tmp6_ = g_strdup (_tmp5_);
	_g_free0 (self->priv->sysfsnode);
	self->priv->sysfsnode = _tmp6_;
	_tmp7_ = sysfsnode;
	_tmp8_ = g_path_get_basename (_tmp7_);
	_g_free0 (self->priv->name);
	self->priv->name = _tmp8_;
	_tmp9_ = subsystem;
	fso_framework_subsystem_registerObjectForServiceWithPrefix (_tmp9_, FREE_SMARTPHONE_DEVICE_TYPE_POWER_CONTROL, (GBoxedCopyFunc) g_object_ref, g_object_unref, FSO_FRAMEWORK_DEVICE_ServiceDBusName, FSO_FRAMEWORK_DEVICE_PowerControlServicePath, (FreeSmartphoneDevicePowerControl*) self);
	_tmp10_ = ((FsoFrameworkAbstractObject*) self)->logger;
	fso_framework_logger_info (_tmp10_, "created.");
	return self;
}


OpenmokoWiFiPowerControl* openmoko_wi_fi_power_control_new (FsoFrameworkSubsystem* subsystem, const gchar* sysfsnode) {
	return openmoko_wi_fi_power_control_construct (OPENMOKO_TYPE_WI_FI_POWER_CONTROL, subsystem, sysfsnode);
}


static gboolean openmoko_wi_fi_power_control_real_getPower (FsoDeviceBasePowerControl* base) {
	OpenmokoWiFiPowerControl * self;
	gboolean result = FALSE;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_;
	self = (OpenmokoWiFiPowerControl*) base;
	_tmp0_ = sysfs_root;
	_tmp1_ = g_build_filename (_tmp0_, "class", "net", "eth0", NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = fso_framework_file_handling_isPresent (_tmp2_);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	result = _tmp4_;
	return result;
}


static void openmoko_wi_fi_power_control_real_setPower (FsoDeviceBasePowerControl* base, gboolean on) {
	OpenmokoWiFiPowerControl * self;
	const gchar* _tmp0_ = NULL;
	gboolean _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* powernode;
	const gchar* _tmp4_;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	self = (OpenmokoWiFiPowerControl*) base;
	_tmp1_ = on;
	if (_tmp1_) {
		_tmp0_ = "bind";
	} else {
		_tmp0_ = "unbind";
	}
	_tmp2_ = _tmp0_;
	_tmp3_ = g_strdup (_tmp2_);
	powernode = _tmp3_;
	_tmp4_ = self->priv->sysfsnode;
	_tmp5_ = g_build_filename (_tmp4_, powernode, NULL);
	_tmp6_ = _tmp5_;
	fso_framework_file_handling_write ("s3c2440-sdi", _tmp6_, FALSE);
	_g_free0 (_tmp6_);
	_g_free0 (powernode);
}


static void openmoko_wi_fi_power_control_class_init (OpenmokoWiFiPowerControlClass * klass) {
	openmoko_wi_fi_power_control_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (OpenmokoWiFiPowerControlPrivate));
	FSO_DEVICE_BASE_POWER_CONTROL_CLASS (klass)->getPower = openmoko_wi_fi_power_control_real_getPower;
	FSO_DEVICE_BASE_POWER_CONTROL_CLASS (klass)->setPower = openmoko_wi_fi_power_control_real_setPower;
	G_OBJECT_CLASS (klass)->finalize = openmoko_wi_fi_power_control_finalize;
}


static void openmoko_wi_fi_power_control_instance_init (OpenmokoWiFiPowerControl * self) {
	self->priv = OPENMOKO_WI_FI_POWER_CONTROL_GET_PRIVATE (self);
}


static void openmoko_wi_fi_power_control_finalize (GObject* obj) {
	OpenmokoWiFiPowerControl * self;
	self = OPENMOKO_WI_FI_POWER_CONTROL (obj);
	_g_object_unref0 (self->priv->subsystem);
	_g_free0 (self->priv->sysfsnode);
	_g_free0 (self->priv->name);
	G_OBJECT_CLASS (openmoko_wi_fi_power_control_parent_class)->finalize (obj);
}


/**
 * WiFi power control for Openmoko GTA02
 **/
GType openmoko_wi_fi_power_control_get_type (void) {
	return openmoko_wi_fi_power_control_type_id;
}


GType openmoko_wi_fi_power_control_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (OpenmokoWiFiPowerControlClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) openmoko_wi_fi_power_control_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (OpenmokoWiFiPowerControl), 0, (GInstanceInitFunc) openmoko_wi_fi_power_control_instance_init, NULL };
	openmoko_wi_fi_power_control_type_id = g_type_module_register_type (module, FSO_DEVICE_TYPE_BASE_POWER_CONTROL, "OpenmokoWiFiPowerControl", &g_define_type_info, 0);
	return openmoko_wi_fi_power_control_type_id;
}


/**
 * This function gets called on plugin initialization time.
 * @return the name of your plugin here
 * @note that it needs to be a name in the format <subsystem>.<plugin>
 * else your module will be unloaded immediately.
 **/
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error) {
	gchar* result = NULL;
	FsoFrameworkSmartKeyFile* _tmp0_;
	FsoFrameworkSmartKeyFile* _tmp1_;
	FsoFrameworkSmartKeyFile* config;
	FsoFrameworkSmartKeyFile* _tmp2_;
	gchar* _tmp3_ = NULL;
	const gchar* _tmp4_;
	gchar* _tmp5_ = NULL;
	gchar* devices;
	const gchar* _tmp6_;
	gchar* _tmp7_ = NULL;
	gchar* drivers;
	FsoFrameworkSmartKeyFile* _tmp8_;
	gboolean _tmp9_ = FALSE;
	gboolean ignore_bluetooth;
	FsoFrameworkSmartKeyFile* _tmp10_;
	gboolean _tmp11_ = FALSE;
	gboolean ignore_gps;
	FsoFrameworkSmartKeyFile* _tmp12_;
	gboolean _tmp13_ = FALSE;
	gboolean ignore_wifi;
	FsoFrameworkSmartKeyFile* _tmp14_;
	gboolean _tmp15_ = FALSE;
	gboolean ignore_usbhost;
	gboolean _tmp16_;
	gboolean _tmp26_;
	gboolean _tmp36_;
	gboolean _tmp46_;
	gchar* _tmp56_;
	g_return_val_if_fail (subsystem != NULL, NULL);
	_tmp0_ = fso_framework_theConfig;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	config = _tmp1_;
	_tmp2_ = config;
	_tmp3_ = fso_framework_smart_key_file_stringValue (_tmp2_, "cornucopia", "sysfs_root", "/sys");
	_g_free0 (sysfs_root);
	sysfs_root = _tmp3_;
	_tmp4_ = sysfs_root;
	_tmp5_ = g_build_filename (_tmp4_, "bus", "platform", "devices", NULL);
	devices = _tmp5_;
	_tmp6_ = sysfs_root;
	_tmp7_ = g_build_filename (_tmp6_, "bus", "platform", "drivers", NULL);
	drivers = _tmp7_;
	_tmp8_ = config;
	_tmp9_ = fso_framework_smart_key_file_boolValue (_tmp8_, OPENMOKO_CONFIG_SECTION, "ignore_bluetooth", FALSE);
	ignore_bluetooth = _tmp9_;
	_tmp10_ = config;
	_tmp11_ = fso_framework_smart_key_file_boolValue (_tmp10_, OPENMOKO_CONFIG_SECTION, "ignore_gps", FALSE);
	ignore_gps = _tmp11_;
	_tmp12_ = config;
	_tmp13_ = fso_framework_smart_key_file_boolValue (_tmp12_, OPENMOKO_CONFIG_SECTION, "ignore_wifi", FALSE);
	ignore_wifi = _tmp13_;
	_tmp14_ = config;
	_tmp15_ = fso_framework_smart_key_file_boolValue (_tmp14_, OPENMOKO_CONFIG_SECTION, "ignore_usbhost", FALSE);
	ignore_usbhost = _tmp15_;
	_tmp16_ = ignore_bluetooth;
	if (!_tmp16_) {
		const gchar* _tmp17_;
		gchar* _tmp18_ = NULL;
		gchar* bluetooth;
		const gchar* _tmp19_;
		gboolean _tmp20_ = FALSE;
		_tmp17_ = devices;
		_tmp18_ = g_build_filename (_tmp17_, "gta02-pm-bt.0", NULL);
		bluetooth = _tmp18_;
		_tmp19_ = bluetooth;
		_tmp20_ = fso_framework_file_handling_isPresent (_tmp19_);
		if (_tmp20_) {
			FsoFrameworkSubsystem* _tmp21_;
			const gchar* _tmp22_;
			OpenmokoDevicePowerControl* _tmp23_;
			OpenmokoDevicePowerControl* o;
			OpenmokoDevicePowerControl* _tmp24_;
			FsoDeviceBasePowerControl* _tmp25_;
			_tmp21_ = subsystem;
			_tmp22_ = bluetooth;
			_tmp23_ = openmoko_device_power_control_new (_tmp21_, _tmp22_);
			o = _tmp23_;
			_tmp24_ = o;
			_tmp25_ = _g_object_ref0 ((FsoDeviceBasePowerControl*) _tmp24_);
			instances = g_list_append (instances, _tmp25_);
			_g_object_unref0 (o);
		}
		_g_free0 (bluetooth);
	}
	_tmp26_ = ignore_gps;
	if (!_tmp26_) {
		const gchar* _tmp27_;
		gchar* _tmp28_ = NULL;
		gchar* gps;
		const gchar* _tmp29_;
		gboolean _tmp30_ = FALSE;
		_tmp27_ = devices;
		_tmp28_ = g_build_filename (_tmp27_, "gta02-pm-gps.0", NULL);
		gps = _tmp28_;
		_tmp29_ = gps;
		_tmp30_ = fso_framework_file_handling_isPresent (_tmp29_);
		if (_tmp30_) {
			FsoFrameworkSubsystem* _tmp31_;
			const gchar* _tmp32_;
			OpenmokoDevicePowerControl* _tmp33_;
			OpenmokoDevicePowerControl* o;
			OpenmokoDevicePowerControl* _tmp34_;
			FsoDeviceBasePowerControl* _tmp35_;
			_tmp31_ = subsystem;
			_tmp32_ = gps;
			_tmp33_ = openmoko_device_power_control_new (_tmp31_, _tmp32_);
			o = _tmp33_;
			_tmp34_ = o;
			_tmp35_ = _g_object_ref0 ((FsoDeviceBasePowerControl*) _tmp34_);
			instances = g_list_append (instances, _tmp35_);
			_g_object_unref0 (o);
		}
		_g_free0 (gps);
	}
	_tmp36_ = ignore_usbhost;
	if (!_tmp36_) {
		const gchar* _tmp37_;
		gchar* _tmp38_ = NULL;
		gchar* usbhost;
		const gchar* _tmp39_;
		gboolean _tmp40_ = FALSE;
		_tmp37_ = devices;
		_tmp38_ = g_build_filename (_tmp37_, "gta02-pm-usbhost.0", NULL);
		usbhost = _tmp38_;
		_tmp39_ = usbhost;
		_tmp40_ = fso_framework_file_handling_isPresent (_tmp39_);
		if (_tmp40_) {
			FsoFrameworkSubsystem* _tmp41_;
			const gchar* _tmp42_;
			OpenmokoUsbHostModeControl* _tmp43_;
			OpenmokoUsbHostModeControl* o;
			OpenmokoUsbHostModeControl* _tmp44_;
			FsoDeviceBasePowerControl* _tmp45_;
			_tmp41_ = subsystem;
			_tmp42_ = usbhost;
			_tmp43_ = openmoko_usb_host_mode_control_new (_tmp41_, _tmp42_);
			o = _tmp43_;
			_tmp44_ = o;
			_tmp45_ = _g_object_ref0 ((FsoDeviceBasePowerControl*) _tmp44_);
			instances = g_list_append (instances, _tmp45_);
			_g_object_unref0 (o);
		}
		_g_free0 (usbhost);
	}
	_tmp46_ = ignore_wifi;
	if (!_tmp46_) {
		const gchar* _tmp47_;
		gchar* _tmp48_ = NULL;
		gchar* wifi;
		const gchar* _tmp49_;
		gboolean _tmp50_ = FALSE;
		_tmp47_ = drivers;
		_tmp48_ = g_build_filename (_tmp47_, "s3c2440-sdi", NULL);
		wifi = _tmp48_;
		_tmp49_ = wifi;
		_tmp50_ = fso_framework_file_handling_isPresent (_tmp49_);
		if (_tmp50_) {
			FsoFrameworkSubsystem* _tmp51_;
			const gchar* _tmp52_;
			OpenmokoWiFiPowerControl* _tmp53_;
			OpenmokoWiFiPowerControl* o;
			OpenmokoWiFiPowerControl* _tmp54_;
			FsoDeviceBasePowerControl* _tmp55_;
			_tmp51_ = subsystem;
			_tmp52_ = wifi;
			_tmp53_ = openmoko_wi_fi_power_control_new (_tmp51_, _tmp52_);
			o = _tmp53_;
			_tmp54_ = o;
			_tmp55_ = _g_object_ref0 ((FsoDeviceBasePowerControl*) _tmp54_);
			instances = g_list_append (instances, _tmp55_);
			_g_object_unref0 (o);
		}
		_g_free0 (wifi);
	}
	_tmp56_ = g_strdup (OPENMOKO_CONFIG_SECTION);
	result = _tmp56_;
	_g_free0 (drivers);
	_g_free0 (devices);
	_g_object_unref0 (config);
	return result;
}


void fso_register_function (GTypeModule* module) {
	FsoFrameworkLogger* _tmp0_;
	g_return_if_fail (module != NULL);
	openmoko_device_power_control_register_type (module);
	openmoko_usb_host_mode_control_register_type (module);
	openmoko_wi_fi_power_control_register_type (module);
	_tmp0_ = fso_framework_theLogger;
	fso_framework_logger_debug (_tmp0_, "fsodevice.openmoko_powercontrol fso_register_function()");
}



