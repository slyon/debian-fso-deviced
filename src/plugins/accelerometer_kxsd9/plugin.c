/* plugin.c generated by valac 0.16.1, the Vala compiler
 * generated from plugin.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <fsodevice.h>
#include <fcntl.h>
#include <sys/types.h>
#include <fsobasics.h>
#include <errno.h>
#include <unistd.h>
#include <linux/input.h>
#include <fsoframework.h>


#define HARDWARE_TYPE_ACCELEROMETER_LIS302 (hardware_accelerometer_lis302_get_type ())
#define HARDWARE_ACCELEROMETER_LIS302(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), HARDWARE_TYPE_ACCELEROMETER_LIS302, HardwareAccelerometerLis302))
#define HARDWARE_ACCELEROMETER_LIS302_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), HARDWARE_TYPE_ACCELEROMETER_LIS302, HardwareAccelerometerLis302Class))
#define HARDWARE_IS_ACCELEROMETER_LIS302(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), HARDWARE_TYPE_ACCELEROMETER_LIS302))
#define HARDWARE_IS_ACCELEROMETER_LIS302_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), HARDWARE_TYPE_ACCELEROMETER_LIS302))
#define HARDWARE_ACCELEROMETER_LIS302_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), HARDWARE_TYPE_ACCELEROMETER_LIS302, HardwareAccelerometerLis302Class))

typedef struct _HardwareAccelerometerLis302 HardwareAccelerometerLis302;
typedef struct _HardwareAccelerometerLis302Class HardwareAccelerometerLis302Class;
typedef struct _HardwareAccelerometerLis302Private HardwareAccelerometerLis302Private;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_io_channel_unref0(var) ((var == NULL) ? NULL : (var = (g_io_channel_unref (var), NULL)))

struct _HardwareAccelerometerLis302 {
	FsoDeviceBaseAccelerometer parent_instance;
	HardwareAccelerometerLis302Private * priv;
	gint fd;
};

struct _HardwareAccelerometerLis302Class {
	FsoDeviceBaseAccelerometerClass parent_class;
};

struct _HardwareAccelerometerLis302Private {
	gchar* inputnode;
	gchar* sysfsnode;
	guint sample_rate;
	guint threshold;
	gchar* full_scale;
	GIOChannel* channel;
	guint watch;
	gint* axis;
	gint axis_length1;
	gint _axis_size_;
	guint timeout;
};


static gpointer hardware_accelerometer_lis302_parent_class = NULL;
static GType hardware_accelerometer_lis302_type_id = 0;

#define HARDWARE_HW_ACCEL_LIS302_PLUGIN_NAME "fsodevice.accelerometer_kxsd9"
#define HARDWARE_DEFAULT_EVENT_NODE "/input/event2"
#define HARDWARE_LIS302_CONFIGURATION_NODE "/bus/spi/drivers/kxsd9dl/spi3.0"
#define HARDWARE_LIS302_DEFAULT_SAMPLERATE 100
#define HARDWARE_LIS302_DEFAULT_THRESHOLD 100
#define HARDWARE_LIS302_DEFAULT_FULLSCALE "2.3"
GType hardware_accelerometer_lis302_get_type (void) G_GNUC_CONST;
GType hardware_accelerometer_lis302_register_type (GTypeModule * module);
#define HARDWARE_ACCELEROMETER_LIS302_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), HARDWARE_TYPE_ACCELEROMETER_LIS302, HardwareAccelerometerLis302Private))
enum  {
	HARDWARE_ACCELEROMETER_LIS302_DUMMY_PROPERTY
};
static gchar* hardware_accelerometer_lis302_real_repr (FsoFrameworkAbstractObject* base);
static gboolean hardware_accelerometer_lis302_feedImpulse (HardwareAccelerometerLis302* self);
static void hardware_accelerometer_lis302_real_start (FsoDeviceBaseAccelerometer* base);
gboolean hardware_accelerometer_lis302_onInputEvent (HardwareAccelerometerLis302* self, GIOChannel* source, GIOCondition condition);
static gboolean _hardware_accelerometer_lis302_onInputEvent_gio_func (GIOChannel* source, GIOCondition condition, gpointer self);
static void hardware_accelerometer_lis302_real_stop (FsoDeviceBaseAccelerometer* base);
static gboolean hardware_accelerometer_lis302_onTimeout (HardwareAccelerometerLis302* self);
static void _hardware_accelerometer_lis302_handleInputEvent (HardwareAccelerometerLis302* self, struct input_event* ev);
static gboolean _hardware_accelerometer_lis302_onTimeout_gsource_func (gpointer self);
HardwareAccelerometerLis302* hardware_accelerometer_lis302_new (void);
HardwareAccelerometerLis302* hardware_accelerometer_lis302_construct (GType object_type);
static GObject * hardware_accelerometer_lis302_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void hardware_accelerometer_lis302_finalize (GObject* obj);
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error);
void fso_register_function (GTypeModule* module);


static gchar* hardware_accelerometer_lis302_real_repr (FsoFrameworkAbstractObject* base) {
	HardwareAccelerometerLis302 * self;
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	self = (HardwareAccelerometerLis302*) base;
	_tmp0_ = self->priv->inputnode;
	_tmp1_ = g_strdup_printf ("<via %s>", _tmp0_);
	result = _tmp1_;
	return result;
}


static gboolean hardware_accelerometer_lis302_feedImpulse (HardwareAccelerometerLis302* self) {
	gboolean result = FALSE;
	gint* _tmp0_;
	gint _tmp0__length1;
	gint _tmp1_;
	gint* _tmp2_;
	gint _tmp2__length1;
	gint _tmp3_;
	gint* _tmp4_;
	gint _tmp4__length1;
	gint _tmp5_;
	gint* _tmp6_;
	gint _tmp6__length1;
	gint _tmp7_;
	gint* _tmp8_;
	gint _tmp8__length1;
	gint _tmp9_;
	gint* _tmp10_;
	gint _tmp10__length1;
	gint _tmp11_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->axis;
	_tmp0__length1 = self->priv->axis_length1;
	_tmp0_[0] = 0;
	_tmp1_ = _tmp0_[0];
	_tmp2_ = self->priv->axis;
	_tmp2__length1 = self->priv->axis_length1;
	_tmp2_[1] = 0;
	_tmp3_ = _tmp2_[1];
	_tmp4_ = self->priv->axis;
	_tmp4__length1 = self->priv->axis_length1;
	_tmp4_[2] = 0;
	_tmp5_ = _tmp4_[2];
	_tmp6_ = self->priv->axis;
	_tmp6__length1 = self->priv->axis_length1;
	_tmp7_ = _tmp6_[0];
	_tmp8_ = self->priv->axis;
	_tmp8__length1 = self->priv->axis_length1;
	_tmp9_ = _tmp8_[1];
	_tmp10_ = self->priv->axis;
	_tmp10__length1 = self->priv->axis_length1;
	_tmp11_ = _tmp10_[2];
	g_signal_emit_by_name ((FsoDeviceBaseAccelerometer*) self, "accelerate", _tmp7_, _tmp9_, _tmp11_);
	result = FALSE;
	return result;
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static gboolean _hardware_accelerometer_lis302_onInputEvent_gio_func (GIOChannel* source, GIOCondition condition, gpointer self) {
	gboolean result;
	result = hardware_accelerometer_lis302_onInputEvent (self, source, condition);
	return result;
}


static void hardware_accelerometer_lis302_real_start (FsoDeviceBaseAccelerometer* base) {
	HardwareAccelerometerLis302 * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_;
	gint _tmp11_;
	GIOChannel* _tmp12_;
	GIOChannel* _tmp13_;
	guint _tmp14_ = 0U;
	self = (HardwareAccelerometerLis302*) base;
	_tmp0_ = self->priv->inputnode;
	_tmp1_ = open (_tmp0_, O_RDONLY, (mode_t) 0);
	self->fd = _tmp1_;
	_tmp2_ = self->fd;
	if (_tmp2_ == (-1)) {
		FsoFrameworkLogger* _tmp3_;
		const gchar* _tmp4_;
		const gchar* _tmp5_ = NULL;
		gint _tmp6_;
		const gchar* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		_tmp3_ = ((FsoFrameworkAbstractObject*) self)->logger;
		_tmp4_ = self->priv->inputnode;
		_tmp5_ = string_to_string (_tmp4_);
		_tmp6_ = errno;
		_tmp7_ = g_strerror (_tmp6_);
		_tmp8_ = string_to_string (_tmp7_);
		_tmp9_ = g_strconcat ("Can't open ", _tmp5_, ": ", _tmp8_, " Lis302 Accelerometer not available.", NULL);
		_tmp10_ = _tmp9_;
		fso_framework_logger_warning (_tmp3_, _tmp10_);
		_g_free0 (_tmp10_);
		return;
	}
	_tmp11_ = self->fd;
	_tmp12_ = g_io_channel_unix_new (_tmp11_);
	_g_io_channel_unref0 (self->priv->channel);
	self->priv->channel = _tmp12_;
	_tmp13_ = self->priv->channel;
	_tmp14_ = g_io_add_watch (_tmp13_, G_IO_IN, _hardware_accelerometer_lis302_onInputEvent_gio_func, self);
	self->priv->watch = _tmp14_;
}


static void hardware_accelerometer_lis302_real_stop (FsoDeviceBaseAccelerometer* base) {
	HardwareAccelerometerLis302 * self;
	guint _tmp0_;
	gint _tmp2_;
	self = (HardwareAccelerometerLis302*) base;
	_tmp0_ = self->priv->watch;
	if (_tmp0_ > ((guint) 0)) {
		guint _tmp1_;
		_tmp1_ = self->priv->watch;
		g_source_remove (_tmp1_);
	}
	_g_io_channel_unref0 (self->priv->channel);
	self->priv->channel = NULL;
	_tmp2_ = self->fd;
	if (_tmp2_ != (-1)) {
		gint _tmp3_;
		_tmp3_ = self->fd;
		close (_tmp3_);
	}
	self->fd = -1;
}


static gboolean hardware_accelerometer_lis302_onTimeout (HardwareAccelerometerLis302* self) {
	gboolean result = FALSE;
	gint* _tmp0_;
	gint _tmp0__length1;
	gint _tmp1_;
	gint* _tmp2_;
	gint _tmp2__length1;
	gint _tmp3_;
	gint* _tmp4_;
	gint _tmp4__length1;
	gint _tmp5_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->axis;
	_tmp0__length1 = self->priv->axis_length1;
	_tmp1_ = _tmp0_[0];
	_tmp2_ = self->priv->axis;
	_tmp2__length1 = self->priv->axis_length1;
	_tmp3_ = _tmp2_[1];
	_tmp4_ = self->priv->axis;
	_tmp4__length1 = self->priv->axis_length1;
	_tmp5_ = _tmp4_[2];
	g_signal_emit_by_name ((FsoDeviceBaseAccelerometer*) self, "accelerate", _tmp1_, _tmp3_, _tmp5_);
	self->priv->timeout = (guint) 0;
	result = FALSE;
	return result;
}


static gboolean _hardware_accelerometer_lis302_onTimeout_gsource_func (gpointer self) {
	gboolean result;
	result = hardware_accelerometer_lis302_onTimeout (self);
	return result;
}


static void _hardware_accelerometer_lis302_handleInputEvent (HardwareAccelerometerLis302* self, struct input_event* ev) {
	struct input_event _tmp0_;
	guint16 _tmp1_;
	gint* _tmp3_;
	gint _tmp3__length1;
	struct input_event _tmp4_;
	guint16 _tmp5_;
	struct input_event _tmp6_;
	gint32 _tmp7_;
	gint _tmp8_;
	guint _tmp9_;
	guint _tmp11_ = 0U;
	g_return_if_fail (self != NULL);
	g_return_if_fail (ev != NULL);
	_tmp0_ = *ev;
	_tmp1_ = _tmp0_.code;
	if (((gint) _tmp1_) > 2) {
		FsoFrameworkLogger* _tmp2_;
		_tmp2_ = ((FsoFrameworkAbstractObject*) self)->logger;
		fso_framework_logger_warning (_tmp2_, "Invalid data from input device. axis > 2");
		return;
	}
	_tmp3_ = self->priv->axis;
	_tmp3__length1 = self->priv->axis_length1;
	_tmp4_ = *ev;
	_tmp5_ = _tmp4_.code;
	_tmp6_ = *ev;
	_tmp7_ = _tmp6_.value;
	_tmp3_[_tmp5_] = (gint) _tmp7_;
	_tmp8_ = _tmp3_[_tmp5_];
	_tmp9_ = self->priv->timeout;
	if (_tmp9_ != ((guint) 0)) {
		guint _tmp10_;
		_tmp10_ = self->priv->timeout;
		g_source_remove (_tmp10_);
	}
	_tmp11_ = g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, (guint) 1, _hardware_accelerometer_lis302_onTimeout_gsource_func, g_object_ref (self), g_object_unref);
	self->priv->timeout = _tmp11_;
}


gboolean hardware_accelerometer_lis302_onInputEvent (HardwareAccelerometerLis302* self, GIOChannel* source, GIOCondition condition) {
	gboolean result = FALSE;
	struct input_event _tmp0_ = {0};
	struct input_event ev;
	GIOChannel* _tmp1_;
	gint _tmp2_ = 0;
	gssize _tmp3_ = 0L;
	gssize bytesread;
	gssize _tmp4_;
	struct input_event _tmp10_;
	guint16 _tmp11_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (source != NULL, FALSE);
	ev = _tmp0_;
	_tmp1_ = source;
	_tmp2_ = g_io_channel_unix_get_fd (_tmp1_);
	_tmp3_ = read (_tmp2_, &ev, (gsize) sizeof (struct input_event));
	bytesread = _tmp3_;
	_tmp4_ = bytesread;
	if (_tmp4_ == ((gssize) 0)) {
		FsoFrameworkLogger* _tmp5_;
		GIOChannel* _tmp6_;
		gint _tmp7_ = 0;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_;
		_tmp5_ = ((FsoFrameworkAbstractObject*) self)->logger;
		_tmp6_ = source;
		_tmp7_ = g_io_channel_unix_get_fd (_tmp6_);
		_tmp8_ = g_strdup_printf ("could not read from input device fd %d.", _tmp7_);
		_tmp9_ = _tmp8_;
		fso_framework_logger_warning (_tmp5_, _tmp9_);
		_g_free0 (_tmp9_);
		result = FALSE;
		return result;
	}
	_tmp10_ = ev;
	_tmp11_ = _tmp10_.type;
	if (_tmp11_ == EV_ABS) {
		FsoFrameworkLogger* _tmp12_;
		GIOChannel* _tmp13_;
		gint _tmp14_ = 0;
		struct input_event _tmp15_;
		guint16 _tmp16_;
		struct input_event _tmp17_;
		guint16 _tmp18_;
		struct input_event _tmp19_;
		gint32 _tmp20_;
		gchar* _tmp21_ = NULL;
		gchar* _tmp22_;
		_tmp12_ = ((FsoFrameworkAbstractObject*) self)->logger;
		_tmp13_ = source;
		_tmp14_ = g_io_channel_unix_get_fd (_tmp13_);
		_tmp15_ = ev;
		_tmp16_ = _tmp15_.type;
		_tmp17_ = ev;
		_tmp18_ = _tmp17_.code;
		_tmp19_ = ev;
		_tmp20_ = _tmp19_.value;
		_tmp21_ = g_strdup_printf ("input ev %d, %d, %d, %d", _tmp14_, (gint) _tmp16_, (gint) _tmp18_, (gint) _tmp20_);
		_tmp22_ = _tmp21_;
		fso_framework_logger_debug (_tmp12_, _tmp22_);
		_g_free0 (_tmp22_);
		_hardware_accelerometer_lis302_handleInputEvent (self, &ev);
	}
	result = TRUE;
	return result;
}


HardwareAccelerometerLis302* hardware_accelerometer_lis302_construct (GType object_type) {
	HardwareAccelerometerLis302 * self = NULL;
	self = (HardwareAccelerometerLis302*) fso_device_base_accelerometer_construct (object_type);
	return self;
}


HardwareAccelerometerLis302* hardware_accelerometer_lis302_new (void) {
	return hardware_accelerometer_lis302_construct (HARDWARE_TYPE_ACCELEROMETER_LIS302);
}


static GObject * hardware_accelerometer_lis302_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	HardwareAccelerometerLis302 * self;
	FsoFrameworkLogger* _tmp0_;
	FsoFrameworkSmartKeyFile* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* sysfs_root;
	FsoFrameworkSmartKeyFile* _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* devfs_root;
	const gchar* _tmp5_;
	FsoFrameworkSmartKeyFile* _tmp6_;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_;
	gchar* _tmp9_;
	const gchar* _tmp10_;
	gchar* _tmp11_;
	FsoFrameworkSmartKeyFile* _tmp12_;
	gint _tmp13_ = 0;
	FsoFrameworkSmartKeyFile* _tmp14_;
	gint _tmp15_ = 0;
	FsoFrameworkSmartKeyFile* _tmp16_;
	gchar* _tmp17_ = NULL;
	const gchar* _tmp18_;
	gboolean _tmp19_ = FALSE;
	gint* _tmp40_ = NULL;
	parent_class = G_OBJECT_CLASS (hardware_accelerometer_lis302_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = HARDWARE_ACCELEROMETER_LIS302 (obj);
	_tmp0_ = ((FsoFrameworkAbstractObject*) self)->logger;
	fso_framework_logger_info (_tmp0_, "Registering kxsd9 accelerometer");
	_tmp1_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp2_ = fso_framework_smart_key_file_stringValue (_tmp1_, "cornucopia", "sysfs_root", "/sys");
	sysfs_root = _tmp2_;
	_tmp3_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp4_ = fso_framework_smart_key_file_stringValue (_tmp3_, "cornucopia", "devfs_root", "/dev");
	devfs_root = _tmp4_;
	_tmp5_ = devfs_root;
	_tmp6_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp7_ = fso_framework_smart_key_file_stringValue (_tmp6_, HARDWARE_HW_ACCEL_LIS302_PLUGIN_NAME, "inputnode", "/input/event2");
	_tmp8_ = _tmp7_;
	_tmp9_ = g_strconcat (_tmp5_, _tmp8_, NULL);
	_g_free0 (self->priv->inputnode);
	self->priv->inputnode = _tmp9_;
	_g_free0 (_tmp8_);
	_tmp10_ = sysfs_root;
	_tmp11_ = g_strconcat (_tmp10_, HARDWARE_LIS302_CONFIGURATION_NODE, NULL);
	_g_free0 (self->priv->sysfsnode);
	self->priv->sysfsnode = _tmp11_;
	_tmp12_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp13_ = fso_framework_smart_key_file_intValue (_tmp12_, HARDWARE_HW_ACCEL_LIS302_PLUGIN_NAME, "sample_rate", HARDWARE_LIS302_DEFAULT_SAMPLERATE);
	self->priv->sample_rate = (guint) _tmp13_;
	_tmp14_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp15_ = fso_framework_smart_key_file_intValue (_tmp14_, HARDWARE_HW_ACCEL_LIS302_PLUGIN_NAME, "threshold", HARDWARE_LIS302_DEFAULT_THRESHOLD);
	self->priv->threshold = (guint) _tmp15_;
	_tmp16_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp17_ = fso_framework_smart_key_file_stringValue (_tmp16_, HARDWARE_HW_ACCEL_LIS302_PLUGIN_NAME, "full_scale", HARDWARE_LIS302_DEFAULT_FULLSCALE);
	_g_free0 (self->priv->full_scale);
	self->priv->full_scale = _tmp17_;
	_tmp18_ = self->priv->sysfsnode;
	_tmp19_ = fso_framework_file_handling_isPresent (_tmp18_);
	if (!_tmp19_) {
		FsoFrameworkLogger* _tmp20_;
		const gchar* _tmp21_;
		gchar* _tmp22_ = NULL;
		gchar* _tmp23_;
		_tmp20_ = ((FsoFrameworkAbstractObject*) self)->logger;
		_tmp21_ = self->priv->sysfsnode;
		_tmp22_ = g_strdup_printf ("Lis302 configuration sysfs not available at %s. Accelerometer will not" \
" work properly.", _tmp21_);
		_tmp23_ = _tmp22_;
		fso_framework_logger_warning (_tmp20_, _tmp23_);
		_g_free0 (_tmp23_);
	} else {
		guint _tmp24_;
		gchar* _tmp25_ = NULL;
		gchar* _tmp26_;
		const gchar* _tmp27_;
		gchar* _tmp28_;
		gchar* _tmp29_;
		guint _tmp30_;
		gchar* _tmp31_ = NULL;
		gchar* _tmp32_;
		const gchar* _tmp33_;
		gchar* _tmp34_;
		gchar* _tmp35_;
		const gchar* _tmp36_;
		const gchar* _tmp37_;
		gchar* _tmp38_;
		gchar* _tmp39_;
		_tmp24_ = self->priv->sample_rate;
		_tmp25_ = g_strdup_printf ("%u", _tmp24_);
		_tmp26_ = _tmp25_;
		_tmp27_ = self->priv->sysfsnode;
		_tmp28_ = g_strconcat (_tmp27_, "/sample_rate", NULL);
		_tmp29_ = _tmp28_;
		fso_framework_file_handling_write (_tmp26_, _tmp29_, FALSE);
		_g_free0 (_tmp29_);
		_g_free0 (_tmp26_);
		_tmp30_ = self->priv->threshold;
		_tmp31_ = g_strdup_printf ("%u", _tmp30_);
		_tmp32_ = _tmp31_;
		_tmp33_ = self->priv->sysfsnode;
		_tmp34_ = g_strconcat (_tmp33_, "/threshold", NULL);
		_tmp35_ = _tmp34_;
		fso_framework_file_handling_write (_tmp32_, _tmp35_, FALSE);
		_g_free0 (_tmp35_);
		_g_free0 (_tmp32_);
		_tmp36_ = self->priv->full_scale;
		_tmp37_ = self->priv->sysfsnode;
		_tmp38_ = g_strconcat (_tmp37_, "/full_scale", NULL);
		_tmp39_ = _tmp38_;
		fso_framework_file_handling_write (_tmp36_, _tmp39_, FALSE);
		_g_free0 (_tmp39_);
	}
	_tmp40_ = g_new0 (gint, 3);
	self->priv->axis = (g_free (self->priv->axis), NULL);
	self->priv->axis = _tmp40_;
	self->priv->axis_length1 = 3;
	self->priv->_axis_size_ = self->priv->axis_length1;
	_g_free0 (devfs_root);
	_g_free0 (sysfs_root);
	return obj;
}


static void hardware_accelerometer_lis302_class_init (HardwareAccelerometerLis302Class * klass) {
	hardware_accelerometer_lis302_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (HardwareAccelerometerLis302Private));
	FSO_FRAMEWORK_ABSTRACT_OBJECT_CLASS (klass)->repr = hardware_accelerometer_lis302_real_repr;
	FSO_DEVICE_BASE_ACCELEROMETER_CLASS (klass)->start = hardware_accelerometer_lis302_real_start;
	FSO_DEVICE_BASE_ACCELEROMETER_CLASS (klass)->stop = hardware_accelerometer_lis302_real_stop;
	G_OBJECT_CLASS (klass)->constructor = hardware_accelerometer_lis302_constructor;
	G_OBJECT_CLASS (klass)->finalize = hardware_accelerometer_lis302_finalize;
}


static void hardware_accelerometer_lis302_instance_init (HardwareAccelerometerLis302 * self) {
	self->priv = HARDWARE_ACCELEROMETER_LIS302_GET_PRIVATE (self);
	self->fd = -1;
}


static void hardware_accelerometer_lis302_finalize (GObject* obj) {
	HardwareAccelerometerLis302 * self;
	self = HARDWARE_ACCELEROMETER_LIS302 (obj);
	_g_free0 (self->priv->inputnode);
	_g_free0 (self->priv->sysfsnode);
	_g_free0 (self->priv->full_scale);
	_g_io_channel_unref0 (self->priv->channel);
	self->priv->axis = (g_free (self->priv->axis), NULL);
	G_OBJECT_CLASS (hardware_accelerometer_lis302_parent_class)->finalize (obj);
}


GType hardware_accelerometer_lis302_get_type (void) {
	return hardware_accelerometer_lis302_type_id;
}


GType hardware_accelerometer_lis302_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (HardwareAccelerometerLis302Class), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) hardware_accelerometer_lis302_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (HardwareAccelerometerLis302), 0, (GInstanceInitFunc) hardware_accelerometer_lis302_instance_init, NULL };
	hardware_accelerometer_lis302_type_id = g_type_module_register_type (module, FSO_DEVICE_TYPE_BASE_ACCELEROMETER, "HardwareAccelerometerLis302", &g_define_type_info, 0);
	return hardware_accelerometer_lis302_type_id;
}


/**
 * This function gets called on plugin initialization time.
 * @return the name of your plugin here
 * @note that it needs to be a name in the format <subsystem>.<plugin>
 * else your module will be unloaded immediately.
 **/
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (subsystem != NULL, NULL);
	_tmp0_ = g_strdup ("fsodevice.accelerometer_kxsd9");
	result = _tmp0_;
	return result;
}


void fso_register_function (GTypeModule* module) {
	FsoFrameworkLogger* _tmp0_;
	g_return_if_fail (module != NULL);
	hardware_accelerometer_lis302_register_type (module);
	_tmp0_ = fso_framework_theLogger;
	fso_framework_logger_debug (_tmp0_, "fsodevice.accelerometer_kxsd9 fso_register_function");
}



