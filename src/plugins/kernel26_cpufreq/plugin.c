/* plugin.c generated by valac 0.16.1, the Vala compiler
 * generated from plugin.vala, do not modify */

/*
 * (C) 2010-2012 Klaus 'mrmoku' Kurzmann <mok@fluxnetz.de>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <fsobasics.h>
#include <fsoframework.h>
#include <glib/gstdio.h>


#define KERNEL26_TYPE_CPU_FREQ (kernel26_cpu_freq_get_type ())
#define KERNEL26_CPU_FREQ(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KERNEL26_TYPE_CPU_FREQ, Kernel26CpuFreq))
#define KERNEL26_CPU_FREQ_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KERNEL26_TYPE_CPU_FREQ, Kernel26CpuFreqClass))
#define KERNEL26_IS_CPU_FREQ(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KERNEL26_TYPE_CPU_FREQ))
#define KERNEL26_IS_CPU_FREQ_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KERNEL26_TYPE_CPU_FREQ))
#define KERNEL26_CPU_FREQ_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KERNEL26_TYPE_CPU_FREQ, Kernel26CpuFreqClass))

typedef struct _Kernel26CpuFreq Kernel26CpuFreq;
typedef struct _Kernel26CpuFreqClass Kernel26CpuFreqClass;
typedef struct _Kernel26CpuFreqPrivate Kernel26CpuFreqPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_dir_close0(var) ((var == NULL) ? NULL : (var = (g_dir_close (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _Kernel26CpuFreq {
	FsoFrameworkAbstractObject parent_instance;
	Kernel26CpuFreqPrivate * priv;
};

struct _Kernel26CpuFreqClass {
	FsoFrameworkAbstractObjectClass parent_class;
};

struct _Kernel26CpuFreqPrivate {
	FsoFrameworkSubsystem* subsystem;
};


static gpointer kernel26_cpu_freq_parent_class = NULL;
extern gchar* default_governor;
extern gint max_frequency;
extern gint min_frequency;
extern GList* sysfs_cpufreq_roots;
static GType kernel26_cpu_freq_type_id = 0;
extern Kernel26CpuFreq* instance;
Kernel26CpuFreq* instance = NULL;
extern gchar* sysfs_root;
gchar* sysfs_root = NULL;
GList* sysfs_cpufreq_roots = NULL;
gchar* default_governor = NULL;
gint min_frequency = 0;
gint max_frequency = 0;

#define KERNEL26_NODE_NAME_GOVERNOR "scaling_governor"
#define KERNEL26_NODE_NAME_MIN_FREQUENCY "scaling_min_freq"
#define KERNEL26_NODE_NAME_MAX_FREQUENCY "scaling_max_freq"
GType kernel26_cpu_freq_get_type (void) G_GNUC_CONST;
GType kernel26_cpu_freq_register_type (GTypeModule * module);
#define KERNEL26_CPU_FREQ_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), KERNEL26_TYPE_CPU_FREQ, Kernel26CpuFreqPrivate))
enum  {
	KERNEL26_CPU_FREQ_DUMMY_PROPERTY
};
Kernel26CpuFreq* kernel26_cpu_freq_new (FsoFrameworkSubsystem* subsystem);
Kernel26CpuFreq* kernel26_cpu_freq_construct (GType object_type, FsoFrameworkSubsystem* subsystem);
static void _kernel26_cpu_freq_setGovernor (Kernel26CpuFreq* self, const gchar* governor);
static void _kernel26_cpu_freq_setFrequency (Kernel26CpuFreq* self, const gchar* node_name, gint frequency);
static gchar* kernel26_cpu_freq_real_repr (FsoFrameworkAbstractObject* base);
static void _kernel26_cpu_freq_checkAndAddCpu (Kernel26CpuFreq* self, const gchar* path);
static void kernel26_cpu_freq_finalize (GObject* obj);
#define MODULE_NAME "fsodevice.kernel26_cpufreq"
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error);
void fso_register_function (GTypeModule* module);

static GRegex* _tmp_regex_0 = NULL;

static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


Kernel26CpuFreq* kernel26_cpu_freq_construct (GType object_type, FsoFrameworkSubsystem* subsystem) {
	Kernel26CpuFreq * self = NULL;
	FsoFrameworkSubsystem* _tmp0_;
	FsoFrameworkSubsystem* _tmp1_;
	const gchar* _tmp2_;
	gint _tmp3_;
	gint _tmp5_;
	FsoFrameworkLogger* _tmp7_;
	g_return_val_if_fail (subsystem != NULL, NULL);
	self = (Kernel26CpuFreq*) fso_framework_abstract_object_construct (object_type);
	_tmp0_ = subsystem;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->subsystem);
	self->priv->subsystem = _tmp1_;
	_tmp2_ = default_governor;
	_kernel26_cpu_freq_setGovernor (self, _tmp2_);
	_tmp3_ = max_frequency;
	if (_tmp3_ > 0) {
		gint _tmp4_;
		_tmp4_ = max_frequency;
		_kernel26_cpu_freq_setFrequency (self, KERNEL26_NODE_NAME_MAX_FREQUENCY, _tmp4_);
	}
	_tmp5_ = min_frequency;
	if (_tmp5_ > 0) {
		gint _tmp6_;
		_tmp6_ = min_frequency;
		_kernel26_cpu_freq_setFrequency (self, KERNEL26_NODE_NAME_MIN_FREQUENCY, _tmp6_);
	}
	_tmp7_ = ((FsoFrameworkAbstractObject*) self)->logger;
	fso_framework_logger_info (_tmp7_, "Created");
	return self;
}


Kernel26CpuFreq* kernel26_cpu_freq_new (FsoFrameworkSubsystem* subsystem) {
	return kernel26_cpu_freq_construct (KERNEL26_TYPE_CPU_FREQ, subsystem);
}


static gchar* kernel26_cpu_freq_real_repr (FsoFrameworkAbstractObject* base) {
	Kernel26CpuFreq * self;
	gchar* result = NULL;
	gchar* _tmp0_;
	self = (Kernel26CpuFreq*) base;
	_tmp0_ = g_strdup ("<>");
	result = _tmp0_;
	return result;
}


static void _kernel26_cpu_freq_checkAndAddCpu (Kernel26CpuFreq* self, const gchar* path) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static void _kernel26_cpu_freq_setGovernor (Kernel26CpuFreq* self, const gchar* governor) {
	FsoFrameworkLogger* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	GList* _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (governor != NULL);
	_tmp0_ = ((FsoFrameworkAbstractObject*) self)->logger;
	_tmp1_ = governor;
	_tmp2_ = string_to_string (_tmp1_);
	_tmp3_ = g_strconcat ("setting governor to ", _tmp2_, NULL);
	_tmp4_ = _tmp3_;
	fso_framework_logger_debug (_tmp0_, _tmp4_);
	_g_free0 (_tmp4_);
	_tmp5_ = sysfs_cpufreq_roots;
	{
		GList* node_collection = NULL;
		GList* node_it = NULL;
		node_collection = _tmp5_;
		for (node_it = node_collection; node_it != NULL; node_it = node_it->next) {
			gchar* _tmp6_;
			gchar* node = NULL;
			_tmp6_ = g_strdup ((const gchar*) node_it->data);
			node = _tmp6_;
			{
				const gchar* _tmp7_;
				const gchar* _tmp8_;
				gchar* _tmp9_;
				gchar* _tmp10_;
				_tmp7_ = governor;
				_tmp8_ = node;
				_tmp9_ = g_strconcat (_tmp8_, "/scaling_governor", NULL);
				_tmp10_ = _tmp9_;
				fso_framework_file_handling_write (_tmp7_, _tmp10_, FALSE);
				_g_free0 (_tmp10_);
				_g_free0 (node);
			}
		}
	}
}


static void _kernel26_cpu_freq_setFrequency (Kernel26CpuFreq* self, const gchar* node_name, gint frequency) {
	FsoFrameworkLogger* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_ = NULL;
	gint _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	GList* _tmp8_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (node_name != NULL);
	_tmp0_ = ((FsoFrameworkAbstractObject*) self)->logger;
	_tmp1_ = node_name;
	_tmp2_ = string_to_string (_tmp1_);
	_tmp3_ = frequency;
	_tmp4_ = g_strdup_printf ("%i", _tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_strconcat ("setting ", _tmp2_, " to ", _tmp5_, NULL);
	_tmp7_ = _tmp6_;
	fso_framework_logger_debug (_tmp0_, _tmp7_);
	_g_free0 (_tmp7_);
	_g_free0 (_tmp5_);
	_tmp8_ = sysfs_cpufreq_roots;
	{
		GList* node_collection = NULL;
		GList* node_it = NULL;
		node_collection = _tmp8_;
		for (node_it = node_collection; node_it != NULL; node_it = node_it->next) {
			gchar* _tmp9_;
			gchar* node = NULL;
			_tmp9_ = g_strdup ((const gchar*) node_it->data);
			node = _tmp9_;
			{
				gint _tmp10_;
				gchar* _tmp11_ = NULL;
				gchar* _tmp12_;
				const gchar* _tmp13_;
				gchar* _tmp14_;
				gchar* _tmp15_;
				const gchar* _tmp16_;
				gchar* _tmp17_;
				gchar* _tmp18_;
				_tmp10_ = frequency;
				_tmp11_ = g_strdup_printf ("%i", _tmp10_);
				_tmp12_ = _tmp11_;
				_tmp13_ = node;
				_tmp14_ = g_strconcat (_tmp13_, "/", NULL);
				_tmp15_ = _tmp14_;
				_tmp16_ = node_name;
				_tmp17_ = g_strconcat (_tmp15_, _tmp16_, NULL);
				_tmp18_ = _tmp17_;
				fso_framework_file_handling_write (_tmp12_, _tmp18_, FALSE);
				_g_free0 (_tmp18_);
				_g_free0 (_tmp15_);
				_g_free0 (_tmp12_);
				_g_free0 (node);
			}
		}
	}
}


static void kernel26_cpu_freq_class_init (Kernel26CpuFreqClass * klass) {
	kernel26_cpu_freq_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (Kernel26CpuFreqPrivate));
	FSO_FRAMEWORK_ABSTRACT_OBJECT_CLASS (klass)->repr = kernel26_cpu_freq_real_repr;
	G_OBJECT_CLASS (klass)->finalize = kernel26_cpu_freq_finalize;
}


static void kernel26_cpu_freq_instance_init (Kernel26CpuFreq * self) {
	self->priv = KERNEL26_CPU_FREQ_GET_PRIVATE (self);
}


static void kernel26_cpu_freq_finalize (GObject* obj) {
	Kernel26CpuFreq * self;
	self = KERNEL26_CPU_FREQ (obj);
	_g_object_unref0 (self->priv->subsystem);
	G_OBJECT_CLASS (kernel26_cpu_freq_parent_class)->finalize (obj);
}


/**
 * @class Kernel26.CpuFreq
 *
 * A module to tweak cpufreq depending on configuration and battery condition
 **/
GType kernel26_cpu_freq_get_type (void) {
	return kernel26_cpu_freq_type_id;
}


GType kernel26_cpu_freq_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (Kernel26CpuFreqClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) kernel26_cpu_freq_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Kernel26CpuFreq), 0, (GInstanceInitFunc) kernel26_cpu_freq_instance_init, NULL };
	kernel26_cpu_freq_type_id = g_type_module_register_type (module, FSO_FRAMEWORK_TYPE_ABSTRACT_OBJECT, "Kernel26CpuFreq", &g_define_type_info, 0);
	return kernel26_cpu_freq_type_id;
}


/**
 * This function gets called on plugin initialization time.
 * @return the name of your plugin here
 * @note that it needs to be a name in the format <subsystem>.<plugin>
 * else your module will be unloaded immediately.
 **/
static inline GRegex* _thread_safe_regex_init (GRegex** re, const gchar * pattern, GRegexMatchFlags match_options) {
	if (g_once_init_enter ((volatile gsize*) re)) {
		GRegex* val = g_regex_new (pattern, match_options, 0, NULL);
		g_once_init_leave ((volatile gsize*) re, (gsize) val);
	}
	return *re;
}


gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error) {
	gchar* result = NULL;
	FsoFrameworkSmartKeyFile* _tmp0_;
	FsoFrameworkSmartKeyFile* _tmp1_;
	FsoFrameworkSmartKeyFile* config;
	FsoFrameworkSmartKeyFile* _tmp2_;
	gchar* _tmp3_ = NULL;
	const gchar* _tmp4_;
	gchar* _tmp5_ = NULL;
	gchar* sys_devices_cpu;
	GList* _tmp34_;
	guint _tmp35_ = 0U;
	FsoFrameworkSmartKeyFile* _tmp38_;
	gchar* _tmp39_ = NULL;
	gchar* _tmp40_;
	gchar* _tmp41_ = NULL;
	FsoFrameworkSmartKeyFile* _tmp42_;
	gint _tmp43_ = 0;
	FsoFrameworkSmartKeyFile* _tmp44_;
	gint _tmp45_ = 0;
	FsoFrameworkSubsystem* _tmp46_;
	Kernel26CpuFreq* _tmp47_;
	gchar* _tmp48_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (subsystem != NULL, NULL);
	_tmp0_ = fso_framework_theConfig;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	config = _tmp1_;
	_tmp2_ = config;
	_tmp3_ = fso_framework_smart_key_file_stringValue (_tmp2_, "cornucopia", "sysfs_root", "/sys");
	_g_free0 (sysfs_root);
	sysfs_root = _tmp3_;
	_tmp4_ = sysfs_root;
	_tmp5_ = g_strdup_printf ("%s/devices/system/cpu", _tmp4_);
	sys_devices_cpu = _tmp5_;
	{
		const gchar* _tmp6_;
		GDir* _tmp7_ = NULL;
		GDir* dir;
		GDir* _tmp8_;
		const gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		gchar* entry;
		_tmp6_ = sys_devices_cpu;
		_tmp7_ = g_dir_open (_tmp6_, (guint) 0, &_inner_error_);
		dir = _tmp7_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch0_g_file_error;
			}
			_g_free0 (sys_devices_cpu);
			_g_object_unref0 (config);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp8_ = dir;
		_tmp9_ = g_dir_read_name (_tmp8_);
		_tmp10_ = g_strdup (_tmp9_);
		entry = _tmp10_;
		while (TRUE) {
			const gchar* _tmp11_;
			const gchar* _tmp12_;
			gboolean _tmp13_ = FALSE;
			GDir* _tmp24_;
			const gchar* _tmp25_ = NULL;
			gchar* _tmp26_;
			_tmp11_ = entry;
			if (!(_tmp11_ != NULL)) {
				break;
			}
			_tmp12_ = entry;
			_tmp13_ = g_regex_match (_thread_safe_regex_init (&_tmp_regex_0, "cpu[0-9]", 0 | G_REGEX_CASELESS), _tmp12_, 0, NULL);
			if (_tmp13_) {
				const gchar* _tmp14_;
				const gchar* _tmp15_;
				gchar* _tmp16_ = NULL;
				gchar* _tmp17_;
				gchar* _tmp18_;
				gchar* _tmp19_;
				gchar* node;
				const gchar* _tmp20_;
				gboolean _tmp21_ = FALSE;
				_tmp14_ = sys_devices_cpu;
				_tmp15_ = entry;
				_tmp16_ = g_build_filename (_tmp14_, _tmp15_, NULL);
				_tmp17_ = _tmp16_;
				_tmp18_ = g_strconcat (_tmp17_, "/cpufreq", NULL);
				_tmp19_ = _tmp18_;
				_g_free0 (_tmp17_);
				node = _tmp19_;
				_tmp20_ = node;
				_tmp21_ = g_file_test (_tmp20_, G_FILE_TEST_IS_DIR);
				if (_tmp21_) {
					const gchar* _tmp22_;
					gchar* _tmp23_;
					_tmp22_ = node;
					_tmp23_ = g_strdup (_tmp22_);
					sysfs_cpufreq_roots = g_list_append (sysfs_cpufreq_roots, _tmp23_);
				}
				_g_free0 (node);
			}
			_tmp24_ = dir;
			_tmp25_ = g_dir_read_name (_tmp24_);
			_tmp26_ = g_strdup (_tmp25_);
			_g_free0 (entry);
			entry = _tmp26_;
		}
		_g_free0 (entry);
		_g_dir_close0 (dir);
	}
	goto __finally0;
	__catch0_g_file_error:
	{
		GError* e = NULL;
		FsoFrameworkLogger* _tmp27_;
		GError* _tmp28_;
		const gchar* _tmp29_;
		const gchar* _tmp30_ = NULL;
		gchar* _tmp31_ = NULL;
		gchar* _tmp32_;
		gchar* _tmp33_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp27_ = fso_framework_theLogger;
		_tmp28_ = e;
		_tmp29_ = _tmp28_->message;
		_tmp30_ = string_to_string (_tmp29_);
		_tmp31_ = g_strconcat ("Failed collecting sysfs nodes for cpufreq: ", _tmp30_, NULL);
		_tmp32_ = _tmp31_;
		fso_framework_logger_error (_tmp27_, _tmp32_);
		_g_free0 (_tmp32_);
		_tmp33_ = g_strdup ("");
		result = _tmp33_;
		_g_error_free0 (e);
		_g_free0 (sys_devices_cpu);
		_g_object_unref0 (config);
		return result;
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_free0 (sys_devices_cpu);
		_g_object_unref0 (config);
		return NULL;
	}
	_tmp34_ = sysfs_cpufreq_roots;
	_tmp35_ = g_list_length (_tmp34_);
	if (_tmp35_ == ((guint) 0)) {
		FsoFrameworkLogger* _tmp36_;
		gchar* _tmp37_;
		_tmp36_ = fso_framework_theLogger;
		fso_framework_logger_info (_tmp36_, "No cpufreq sysfs nodes found");
		_tmp37_ = g_strdup ("");
		result = _tmp37_;
		_g_free0 (sys_devices_cpu);
		_g_object_unref0 (config);
		return result;
	}
	_tmp38_ = config;
	_tmp39_ = fso_framework_smart_key_file_stringValue (_tmp38_, MODULE_NAME, "default_governor", "ondemand");
	_tmp40_ = _tmp39_;
	_tmp41_ = g_utf8_strdown (_tmp40_, (gssize) (-1));
	_g_free0 (default_governor);
	default_governor = _tmp41_;
	_g_free0 (_tmp40_);
	_tmp42_ = config;
	_tmp43_ = fso_framework_smart_key_file_intValue (_tmp42_, MODULE_NAME, "min_frequency", 0);
	min_frequency = _tmp43_;
	_tmp44_ = config;
	_tmp45_ = fso_framework_smart_key_file_intValue (_tmp44_, MODULE_NAME, "max_frequency", 0);
	max_frequency = _tmp45_;
	_tmp46_ = subsystem;
	_tmp47_ = kernel26_cpu_freq_new (_tmp46_);
	_g_object_unref0 (instance);
	instance = _tmp47_;
	_tmp48_ = g_strdup ("fsodevice.kernel26_cpufreq");
	result = _tmp48_;
	_g_free0 (sys_devices_cpu);
	_g_object_unref0 (config);
	return result;
}


void fso_register_function (GTypeModule* module) {
	FsoFrameworkLogger* _tmp0_;
	g_return_if_fail (module != NULL);
	kernel26_cpu_freq_register_type (module);
	_tmp0_ = fso_framework_theLogger;
	fso_framework_logger_debug (_tmp0_, "fsodevice.kernel26_cpufreq fso_register_function()");
}



