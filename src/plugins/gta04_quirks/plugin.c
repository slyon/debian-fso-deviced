/* plugin.c generated by valac 0.16.0, the Vala compiler
 * generated from plugin.vala, do not modify */

/*
 * Copyright (C) 2010-2012 Simon Busch <morphis@gravedo.de>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <fsodevice.h>
#include <fsoframework.h>
#include <fsobasics.h>

#define _g_free0(var) (var = (g_free (var), NULL))

#define GTA04_TYPE_GPS_POWER_CONTROL (gta04_gps_power_control_get_type ())
#define GTA04_GPS_POWER_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GTA04_TYPE_GPS_POWER_CONTROL, Gta04GpsPowerControl))
#define GTA04_GPS_POWER_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GTA04_TYPE_GPS_POWER_CONTROL, Gta04GpsPowerControlClass))
#define GTA04_IS_GPS_POWER_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GTA04_TYPE_GPS_POWER_CONTROL))
#define GTA04_IS_GPS_POWER_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GTA04_TYPE_GPS_POWER_CONTROL))
#define GTA04_GPS_POWER_CONTROL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GTA04_TYPE_GPS_POWER_CONTROL, Gta04GpsPowerControlClass))

typedef struct _Gta04GpsPowerControl Gta04GpsPowerControl;
typedef struct _Gta04GpsPowerControlClass Gta04GpsPowerControlClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))


extern GList* resources;
GList* resources = NULL;
extern GList* instances;
GList* instances = NULL;

#define GTA04_MODULE_NAME "fsodevice.gta04_powercontrol"
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error);
Gta04GpsPowerControl* gta04_gps_power_control_new (FsoFrameworkSubsystem* subsystem, const gchar* sysfsnode);
Gta04GpsPowerControl* gta04_gps_power_control_construct (GType object_type, FsoFrameworkSubsystem* subsystem, const gchar* sysfsnode);
GType gta04_gps_power_control_get_type (void) G_GNUC_CONST;
GType gta04_gps_power_control_register_type (GTypeModule * module);
void fso_register_function (GTypeModule* module);


/**
 * This function gets called on plugin initialization time.
 * @return the name of your plugin here
 * @note that it needs to be a name in the format <subsystem>.<plugin>
 * else your module will be unloaded immediately.
 **/
static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error) {
	gchar* result = NULL;
	FsoFrameworkSmartKeyFile* _tmp0_;
	FsoFrameworkSmartKeyFile* _tmp1_;
	FsoFrameworkSmartKeyFile* config;
	FsoFrameworkSmartKeyFile* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* sysfs_root;
	FsoFrameworkSmartKeyFile* _tmp4_;
	const gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp9_;
	gchar* _tmp21_;
	g_return_val_if_fail (subsystem != NULL, NULL);
	_tmp0_ = fso_framework_theConfig;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	config = _tmp1_;
	_tmp2_ = config;
	_tmp3_ = fso_framework_smart_key_file_stringValue (_tmp2_, "cornucopia", "sysfs_root", "/sys");
	sysfs_root = _tmp3_;
	_tmp4_ = config;
	_tmp5_ = string_to_string (GTA04_MODULE_NAME);
	_tmp6_ = g_strconcat (_tmp5_, "/powercontrol", NULL);
	_tmp7_ = _tmp6_;
	_tmp8_ = fso_framework_smart_key_file_hasSection (_tmp4_, _tmp7_);
	_tmp9_ = _tmp8_;
	_g_free0 (_tmp7_);
	if (_tmp9_) {
		const gchar* _tmp10_;
		gchar* _tmp11_ = NULL;
		gchar* gpio;
		const gchar* _tmp12_;
		gchar* _tmp13_ = NULL;
		gchar* gps_gpio;
		const gchar* _tmp14_;
		gboolean _tmp15_ = FALSE;
		_tmp10_ = sysfs_root;
		_tmp11_ = g_build_filename (_tmp10_, "class", "gpio", NULL);
		gpio = _tmp11_;
		_tmp12_ = gpio;
		_tmp13_ = g_build_filename (_tmp12_, "gpio145", NULL);
		gps_gpio = _tmp13_;
		_tmp14_ = gps_gpio;
		_tmp15_ = fso_framework_file_handling_isPresent (_tmp14_);
		if (_tmp15_) {
			FsoFrameworkSubsystem* _tmp16_;
			const gchar* _tmp17_;
			Gta04GpsPowerControl* _tmp18_;
			Gta04GpsPowerControl* o;
			Gta04GpsPowerControl* _tmp19_;
			FsoDeviceBasePowerControl* _tmp20_;
			_tmp16_ = subsystem;
			_tmp17_ = gps_gpio;
			_tmp18_ = gta04_gps_power_control_new (_tmp16_, _tmp17_);
			o = _tmp18_;
			_tmp19_ = o;
			_tmp20_ = _g_object_ref0 ((FsoDeviceBasePowerControl*) _tmp19_);
			instances = g_list_append (instances, _tmp20_);
			_g_object_unref0 (o);
		}
		_g_free0 (gps_gpio);
		_g_free0 (gpio);
	}
	_tmp21_ = g_strdup (GTA04_MODULE_NAME);
	result = _tmp21_;
	_g_free0 (sysfs_root);
	_g_object_unref0 (config);
	return result;
}


void fso_register_function (GTypeModule* module) {
	FsoFrameworkLogger* _tmp0_;
	g_return_if_fail (module != NULL);
	gta04_gps_power_control_register_type (module);
	_tmp0_ = fso_framework_theLogger;
	fso_framework_logger_debug (_tmp0_, "fsodevice.gta04_quirks fso_register_function()");
}



